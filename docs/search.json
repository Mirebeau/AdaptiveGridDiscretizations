[{"fullname": "agd", "modulename": "agd", "qualname": "", "type": "module", "doc": "<p>Adaptive Grid Discretizations (agd) package.</p>\n\n<p>This package is intented as a toolbox for discretizing and solving partial differential\nequations (PDEs), especially in the following contexts : </p>\n\n<ul>\n<li>A Cartesian grid is used for the domain discretization.</li>\n<li>The PDE embeds geometric information, possibly strongly anisotropic.</li>\n<li>One puts a strong emphasis on preserving the structure of the PDE \n(monotony, causality, degenerate ellipticity, ...) at the discrete level.</li>\n<li>Generic CPU/GPU programming.</li>\n</ul>\n\n<p>This package comes with an extensive suite of notebooks, which serve simultaneously the\npurposes of documentation, mathematical description, and testing. Please see \nhttps://github.com/Mirebeau/AdaptiveGridDiscretizations</p>\n\n<p>The AGD package is architectured around the following main components:</p>\n\n<ul>\n<li>AutomaticDifferentiation : automatically compute gradients, hessians, jacobians, in \ndense or sparse format, using operator and function overloading.</li>\n</ul>\n\n<ul>\n<li><p>Eikonal : a ready to use solver of (generalized, anisotropic) eikonal equations. Those\nare partial differential equations which characterize minimal distances w.r.t. Riemannian\nor other classes of metrics.</p></li>\n<li><p>Metrics : helper classes for classical and less classical objects \n(Riemannian metrics, Hooke elasticity tensors, etc) used to encode geometric information.</p></li>\n<li><p>FiniteDifferences, Domain, Interpolation : helper classes for handling function values\nstored in arrays and designing numerical schemes.</p></li>\n<li><p>LinearParallel : basic linear algebra operations, following an axes ordering convention\nsomewhat opposite to numpy's (geometry first).</p></li>\n<li><p>Selling : a decomposition method for symmetric positive definite matrices, which is a \ncentral tool in our designs of anisotropic PDE discretizations.</p></li>\n</ul>\n\n<h1 id=\"adaptive-grid-discretizations-using-lattice-basis-reduction-agd-lbr\">Adaptive Grid Discretizations using Lattice Basis Reduction (AGD-LBR)</h1>\n\n<h2 id=\"a-set-of-tools-for-discretizing-anisotropic-pdes-on-cartesian-grids\">A set of tools for discretizing anisotropic PDEs on cartesian grids</h2>\n\n<p>This repository contains</p>\n\n<ul>\n<li>the agd library (Adaptive Grid Discretizations), written in Python&reg; and cuda&reg;</li>\n<li>a series of <em>jupyter notebooks</em> in the Python&reg; language, reproducing my research in Anisotropic PDE discretizations and their applications.</li>\n<li>a basic documentation, <a href=\"https://mirebeau.github.io/AdaptiveGridDiscretizations/agd.html\">view online</a>,\ngenerated with <a href=\"https://pdoc.dev/\">pdoc</a>.</li>\n</ul>\n\n<h3 id=\"the-agd-library\">The AGD library</h3>\n\n<p>The recommended ways to install are</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"go\">conda install agd -c agd-lbr</span>\n</code></pre></div>\n\n<p>alternatively (required for using the GPU eikonal solver)</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"go\">pip install agd</span>\n</code></pre></div>\n\n<h3 id=\"the-notebooks\">The notebooks</h3>\n\n<p>You may <a href=\"http://nbviewer.jupyter.org/urls/rawgithub.com/Mirebeau/AdaptiveGridDiscretizations_showcase/master/Summary.ipynb\n\">visualize the notebooks online using nbviewer</a>, or experimentally <a href=\"https://colab.research.google.com/notebook#fileId=1exIN-55tUG1LFlgoHM582k8o8zy6H46f&amp;offline=true&amp;sandboxMode=true\">run and modify the notebooks online using GoogleColab</a>.\nYou may need to turn on GPU acceleration in GoogleColab (typical error: cannot import cupy) : Modify->Notebook parameters->GPU.</p>\n\n<p>The notebooks are intended as documentation and testing for the adg library. They encompass:</p>\n\n<ul>\n<li>Anisotropic fast marching methods, for shortest path computation.</li>\n<li>Non-divergence form PDEs, including non-linear PDEs such as Monge-Ampere.</li>\n<li>Divergence form anisotropic PDEs, often encountered in image processing.</li>\n<li>Algorithmic tools, related with lattice basis reduction methods, and automatic differentiation.</li>\n</ul>\n\n<p>For offline consultation, please download and install <a href=\"https://www.anaconda.com\">anaconda</a> or <a href=\"https://conda.io/en/latest/miniconda.html\">miniconda</a>. <br />\n<em>Optionally</em>, you may create a dedicated conda environnement by typing the following in a terminal:</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"go\">conda env create --file agd-hfm.yaml</span>\n<span class=\"go\">conda activate agd-hfm</span>\n</code></pre></div>\n\n<p>In order to open the book summary, type in a terminal:</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"go\">jupyter notebook Summary.ipynb</span>\n</code></pre></div>\n\n<p>Then use the hyperlinks to navigate within the notebooks.</p>\n\n<h3 id=\"matlab-users\">Matlab users</h3>\n\n<p>Recent versions of Matlab are able to call the Python interpreter, and thus to use the \nagd library. See Notebooks_FMM/Matlab for examples featuring the CPU and GPU eikonal solvers.</p>\n"}, {"fullname": "agd.AutomaticDifferentiation", "modulename": "agd.AutomaticDifferentiation", "qualname": "", "type": "module", "doc": "<p>This package implements automatic differentiation (AD) methods, in the following flavors:</p>\n\n<ul>\n<li>Dense, Sparse, and Reverse (experimental) modes</li>\n<li>First and second order differentiation</li>\n<li>CPU and GPU support, using numpy and cupy.\nThe AD types implement numpy's overloading mechanisms, and one should be able to use them\nas drop in replacement for numpy arrays in many contexts.</li>\n</ul>\n\n<p>Main submodules:</p>\n\n<ul>\n<li>Dense : first order, forward AD with dense storage.</li>\n<li>Dense2 : second order, forward AD with dense storage.</li>\n<li>Sparse : first order, forward AD with sparse storage.</li>\n<li>Sparse2 : second order, forward AD with sparse storage.</li>\n<li>Reverse, Reverse2 (experimental) : first and second order, reverse AD.</li>\n<li>Optimization : basic Newton method implemented using AD</li>\n</ul>\n\n<p>Main functions:</p>\n\n<ul>\n<li>asarray, array: turn a list/tuple of arrays into a larger array.</li>\n<li>is_ad : test whether a variable embeds AD information.</li>\n<li>remove_ad : remove AD information</li>\n<li>simplify_ad : compress the AD information, of Sparse and Sparse2 types.</li>\n<li>apply : apply a function to some arguments, using specified AD tricks.</li>\n<li>isndarray : returns true for numpy, cupy, and AD types.</li>\n<li>cupy_friendly : helper function for CPU/GPU generic programming.</li>\n</ul>\n"}, {"fullname": "agd.AutomaticDifferentiation.DeliberateNotebookError", "modulename": "agd.AutomaticDifferentiation", "qualname": "DeliberateNotebookError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.DeliberateNotebookError.__init__", "modulename": "agd.AutomaticDifferentiation", "qualname": "DeliberateNotebookError.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "message"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.AD_CUDA", "modulename": "agd.AutomaticDifferentiation.AD_CUDA", "qualname": "", "type": "module", "doc": "<p>This package is implementation detail for some GPU accelerated methods of the \nAutomaticDifferentation parent package. It should not be used directly</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad", "modulename": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad.simplify_ad", "modulename": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad", "qualname": "simplify_ad", "type": "function", "doc": "<p>Calls the GPU implementation of the simplify_ad method</p>\n", "parameters": ["x", "atol", "rtol", "blockSize"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1", "type": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.__init__", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.pow", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.pow", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "n"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.log", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.log", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.exp", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.exp", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.abs", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.abs", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.sin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.sin", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.cos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.cos", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.tan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.tan", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arcsin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arcsin", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arccos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arccos", "type": "function", "doc": "<p></p>\n", "parameters": ["c"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arctan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arctan", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.sinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.sinh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.cosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.cosh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.tanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.tanh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arcsinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arcsinh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arccosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arccosh", "type": "function", "doc": "<p></p>\n", "parameters": ["c"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arctanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arctanh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2", "type": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.__init__", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.pow", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.pow", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "n"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.log", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.log", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.exp", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.exp", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.abs", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.abs", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.sin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.sin", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.cos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.cos", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.tan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.tan", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arcsin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arcsin", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arccos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arccos", "type": "function", "doc": "<p></p>\n", "parameters": ["c"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arctan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arctan", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.sinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.sinh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.cosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.cosh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.tanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.tanh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arcsinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arcsinh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arccosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arccosh", "type": "function", "doc": "<p></p>\n", "parameters": ["c"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arctanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arctanh", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.add", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "add", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "b", "out", "where"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.subtract", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "subtract", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "b", "out", "where"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.multiply", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "multiply", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "b", "out", "where"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.true_divide", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "true_divide", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "b", "out", "where"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.maximum", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "maximum", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "b"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.minimum", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "minimum", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "b"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD", "type": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.__init__", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.cupy_based", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.cupy_based", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.shape", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.shape", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.ndim", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.ndim", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.size", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.size", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.flatten", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.flatten", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.squeeze", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.squeeze", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.T", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.T", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.stack", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.stack", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.dtype", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.dtype", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.isndarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.isndarray", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.is_ad", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.is_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "other"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.new", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.new", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.Taylor", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.Taylor", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.sqrt", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.sqrt", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.log", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.log", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.exp", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.exp", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.abs", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.abs", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.sin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.sin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.cos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.cos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.tan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.tan", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arcsin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arcsin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arccos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arccos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arctan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arctan", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.sinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.sinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.cosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.cosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.tanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.tanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arcsinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arcsinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arccosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arccosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arctanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arctanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.argmin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.argmin", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.argmax", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.argmax", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.min", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.min", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "axis", "keepdims", "out"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.max", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.max", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "axis", "keepdims", "out"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.prod", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.prod", "type": "function", "doc": "<p>Attempt to reproduce numpy prod function. (Rather inefficiently, and I presume partially)</p>\n", "parameters": ["arr", "axis", "dtype", "out", "keepdims", "initial"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy", "type": "class", "doc": "<p>ndarray(shape, dtype=float, memptr=None, strides=None, order=u'C')\nMulti-dimensional array on a CUDA device.</p>\n\n<pre><code>This class implements a subset of methods of :class:`numpy.ndarray`.\nThe difference is that this class allocates the array content on the\ncurrent GPU device.\n\nArgs:\n    shape (tuple of ints): Length of axes.\n    dtype: Data type. It must be an argument of :class:`numpy.dtype`.\n    memptr (cupy.cuda.MemoryPointer): Pointer to the array content head.\n    strides (tuple of ints or None): Strides of data in memory.\n    order ({'C', 'F'}): Row-major (C-style) or column-major\n        (Fortran-style) order.\n\nAttributes:\n    base (None or cupy.ndarray): Base array from which this array is\n        created as a view.\n    data (cupy.cuda.MemoryPointer): Pointer to the array content head.\n    ~ndarray.dtype(numpy.dtype): Dtype object of element type.\n\n        .. seealso::\n           `Data type objects (dtype)                &lt;https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html&gt;`_\n    ~ndarray.size (int): Number of elements this array holds.\n\n        This is equivalent to product over the shape tuple.\n\n        .. seealso:: :attr:`numpy.ndarray.size`\n</code></pre>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.cupy_based", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.cupy_based", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.shape", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.shape", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.ndim", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.ndim", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.size", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.size", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.flatten", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.flatten", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.squeeze", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.squeeze", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.T", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.T", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.stack", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.stack", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.dtype", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.dtype", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.isndarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.isndarray", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.is_ad", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.is_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "other"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.new", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.new", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.Taylor", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.Taylor", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.sqrt", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.sqrt", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.log", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.log", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.exp", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.exp", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.abs", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.abs", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.sin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.sin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.cos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.cos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.tan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.tan", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.arcsin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.arcsin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.arccos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.arccos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.arctan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.arctan", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.sinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.sinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.cosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.cosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.tanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.tanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.arcsinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.arcsinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.arccosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.arccosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.arctanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.arctanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.argmin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.argmin", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.argmax", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.argmax", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.min", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.min", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "axis", "keepdims", "out"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.max", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.max", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "axis", "keepdims", "out"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD_cupy.prod", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD_cupy.prod", "type": "function", "doc": "<p>Attempt to reproduce numpy prod function. (Rather inefficiently, and I presume partially)</p>\n", "parameters": ["arr", "axis", "dtype", "out", "keepdims", "initial"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.is_ad", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "is_ad", "type": "function", "doc": "<p>Wether the object holds ad information</p>\n", "parameters": ["data", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.isndarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "isndarray", "type": "function", "doc": "<p>Wether the object is a numpy or cupy ndarray, or an adtype</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.from_cupy", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "from_cupy", "type": "function", "doc": "<p>Wether the variable is an instance of a cupy ndarray (incudes AD types)</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.array", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "array", "type": "function", "doc": "<p>Similar to np.array, but does not cast AD subclasses of np.ndarray to the base class.\nTurns a list or tuple of arrays with the same dimensions. \nTurns a scalar into an array scalar.\nInputs : </p>\n\n<ul>\n<li>caster : used to cast a scalar into an array scalar (overrides default)</li>\n</ul>\n", "parameters": ["a", "copy", "caster"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.asarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "asarray", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.cupy_variant", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "cupy_variant", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.array_members", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "array_members", "type": "function", "doc": "<p>Returns the list of all arrays in given structure, with their access paths</p>\n", "parameters": ["data", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.implements", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "implements", "type": "function", "doc": "<p>Register an __array_function__ implementation for MyArray objects.</p>\n", "parameters": ["numpy_function"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.implements_cupy_alt", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "implements_cupy_alt", "type": "function", "doc": "<p>Register an alternative to a numpy function only partially supported by cupy</p>\n", "parameters": ["numpy_function", "exception"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.stack", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "stack", "type": "function", "doc": "<p></p>\n", "parameters": ["elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.expand_dims", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "expand_dims", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.empty_like", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "empty_like", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.copy_to", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "copy_to", "type": "function", "doc": "<p></p>\n", "parameters": ["dst", "src", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.where", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "where", "type": "function", "doc": "<p></p>\n", "parameters": ["mask", "a", "b"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.sort", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "sort", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "axis", "varargs", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.concatenate", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.pad", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "pad", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "pad_width", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.mean", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "mean", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD", "type": "class", "doc": "<p>A class for dense forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.__init__", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.order", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.copy", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.as_tuple", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.as_func", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.compose", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.size_ad", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.gradient", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.gradient", "type": "function", "doc": "<p>Returns the gradient, or the i-th component of the gradient if specified.</p>\n", "parameters": ["self", "i"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.reshape", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.pad", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.transpose", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.sum", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.solve", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.solve", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape_free", "shape_bound"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.concatenate", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.associate", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.associate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "squeeze_free_dims", "squeeze_bound_dims"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.apply_linear_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.cupy_variant", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.cupy_variant", "type": "class", "doc": "<p>A class for dense forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.identity", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "identity", "type": "function", "doc": "<p>Creates a dense AD variable with independent symbolic perturbations for each coordinate\n(unless some are tied together as specified by shape_free and shape_bound)</p>\n", "parameters": ["shape", "shape_free", "shape_bound", "constant", "shift"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.register", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "register", "type": "function", "doc": "<p>Creates a series of dense AD variables with independent symbolic perturbations for each coordinate,\nand adequate intermediate shifts.</p>\n", "parameters": ["inputs", "iterables", "shape_bound", "shift", "ident", "considered"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy", "type": "class", "doc": "<p>A class for dense forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.__init__", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.order", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.copy", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.as_tuple", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.as_func", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.compose", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.size_ad", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.gradient", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.gradient", "type": "function", "doc": "<p>Returns the gradient, or the i-th component of the gradient if specified.</p>\n", "parameters": ["self", "i"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.reshape", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.pad", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.transpose", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.sum", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.solve", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.solve", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape_free", "shape_bound"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.concatenate", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.associate", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.associate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "squeeze_free_dims", "squeeze_bound_dims"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.apply_linear_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_cupy.numpy_variant", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_cupy.numpy_variant", "type": "class", "doc": "<p>A class for dense forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.new", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "new", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2", "type": "class", "doc": "<p>A class for dense forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.__init__", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef1", "coef2", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.order", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.copy", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.as_tuple", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.as_func", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.compose", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.size_ad", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.to_first", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.to_first", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.gradient", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.gradient", "type": "function", "doc": "<p>Returns the gradient, or the i-th component of the gradient if specified.</p>\n", "parameters": ["self", "i"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.hessian", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.hessian", "type": "function", "doc": "<p>Returns the hessian, or component (i,j) of the hessian if specified.</p>\n", "parameters": ["self", "i", "j"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.reshape", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.pad", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.transpose", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.sum", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.concatenate", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.apply_linear_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.cupy_variant", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.cupy_variant", "type": "class", "doc": "<p>A class for dense forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.identity", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "identity", "type": "function", "doc": "<p></p>\n", "parameters": ["args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.register", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "register", "type": "function", "doc": "<p></p>\n", "parameters": ["args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy", "type": "class", "doc": "<p>A class for dense forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.__init__", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef1", "coef2", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.order", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.copy", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.as_tuple", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.as_func", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.compose", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.size_ad", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.to_first", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.to_first", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.gradient", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.gradient", "type": "function", "doc": "<p>Returns the gradient, or the i-th component of the gradient if specified.</p>\n", "parameters": ["self", "i"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.hessian", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.hessian", "type": "function", "doc": "<p>Returns the hessian, or component (i,j) of the hessian if specified.</p>\n", "parameters": ["self", "i", "j"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.reshape", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.pad", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.transpose", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.sum", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.concatenate", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.apply_linear_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2_cupy.numpy_variant", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2_cupy.numpy_variant", "type": "class", "doc": "<p>A class for dense forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.new", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "new", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef1", "coef2", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.norm", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "norm", "type": "function", "doc": "<p>Returns L^p norm of array, seen as a vector, w.r.t. weights.\nDefined as : (sum_i x[i]^p)^(1/p)</p>\n\n<p>Remark : not a matrix operator norm</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>ord : exponent p</li>\n<li>axis : int or None, axis along which to compute the norm. </li>\n<li>keepdims : wether to keep singleton dimensions.</li>\n<li>averaged : wether to introduce a normalization factor, so that norm(ones(...))=1</li>\n</ul>\n\n<p>Compatible with automatic differentiation.</p>\n", "parameters": ["arr", "ord", "axis", "keepdims", "averaged"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.norm_infinity", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "norm_infinity", "type": "function", "doc": "<p>L-Infinity norm (largest absolute value)</p>\n", "parameters": ["arr", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.norm_average", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "norm_average", "type": "function", "doc": "<p>Averaged L1 norm (sum of absolute values divided by array size)</p>\n", "parameters": ["arr", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default", "type": "class", "doc": "<p>Default stopping criterion for the newton method.\nParameters : </p>\n\n<ul>\n<li>residue_tol : target tolerance on the residue infinity norm</li>\n<li>niter_max : max iterations before aborting</li>\n<li>raise_on_abort : wether to raise an exception if aborting</li>\n<li>niter_print : generator for which iterations to print the state</li>\n</ul>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.__init__", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "residue_tol", "niter_max", "raise_on_abort", "niter_print", "verbosity"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.abort", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.abort", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default", "type": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default.__init__", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "criterion", "refine_factor", "step_min", "raise_on_abort"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.newton_root", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "newton_root", "type": "function", "doc": "<p>Newton's method, for finding a root of a given function.\nfunc : function to be solved\nx0 : initial guess for the root\nfprime : method for computin\nstop : stopping criterion\nrelax : added to the jacobian before inversion\ndamping : criterion for step reduction\nad : is either </p>\n\n<ul>\n<li>keyword \"Sparse\" for using Sparse AD (Default)</li>\n<li>keyword \"Dense\" for using Dense AD</li>\n<li>a shape_bound given as a tuple, for Dense AD with few independent variables</li>\n</ul>\n", "parameters": ["func", "x0", "params", "stop", "relax", "damping", "ad", "solver", "in_place"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD", "type": "class", "doc": "<p>A class for reverse first order automatic differentiation.</p>\n\n<p>Fields : </p>\n\n<ul>\n<li>input_iterables : tuple, subset of {tuple,list,dict,set}.\n    Which input structures should be explored when looking for AD information</li>\n<li>output_iterables : tuple subset of (tuple,list,dict).\n    Which output structures should be explored looking for AD information</li>\n</ul>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.__init__", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "operator_data", "input_iterables", "output_iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.size_ad", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.size_rev", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.size_rev", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.register", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.register", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.identity", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.identity", "type": "function", "doc": "<p>Creates and register a new AD variable</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.apply", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.apply", "type": "function", "doc": "<p>Applies a function on the given args, saving adequate data\nfor reverse AD.</p>\n", "parameters": ["self", "func", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.apply_linear_mapping", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.apply_linear_mapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "matrix", "rhs", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.apply_linear_inverse", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.apply_linear_inverse", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "solver", "matrix", "rhs", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.simplify", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.simplify", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "rhs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.iterate", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.iterate", "type": "function", "doc": "<p>Input: function, variable to be updated, niter, nrec, optional args\nIterates a function, saving adequate data for reverse AD. \nIf nrec>0, a recursive strategy is used to limit the amount of data saved.</p>\n", "parameters": ["self", "func", "var", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.to_inputshapes", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.to_inputshapes", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.gradient", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.gradient", "type": "function", "doc": "<p>Computes the gradient of the scalar spAD variable a</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.output", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.output", "type": "function", "doc": "<p>Computes the gradient of the output a, times the co_state, for an operator_like reverseAD</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.empty", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "empty", "type": "function", "doc": "<p></p>\n", "parameters": ["inputs", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.operator_like", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "operator_like", "type": "function", "doc": "<p>Operator_like reverseAD (or reverseAD2 depending on co_output): </p>\n\n<ul>\n<li>has a fixed co_output</li>\n</ul>\n", "parameters": ["inputs", "co_output", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.linear_inverse_with_adjoint", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "linear_inverse_with_adjoint", "type": "function", "doc": "<p></p>\n", "parameters": ["solver", "matrix", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.linear_mapping_with_adjoint", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "linear_mapping_with_adjoint", "type": "function", "doc": "<p></p>\n", "parameters": ["matrix", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.identity_with_adjoint", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "identity_with_adjoint", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "co_output"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2", "type": "class", "doc": "<p>A class for reverse second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.__init__", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "operator_data", "input_iterables", "output_iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.size_ad", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.size_rev", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.size_rev", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.register", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.register", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.identity", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.identity", "type": "function", "doc": "<p>Creates and registers a new AD variable</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.apply", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.apply", "type": "function", "doc": "<p>Applies a function on the given args, saving adequate data\nfor reverse AD.</p>\n", "parameters": ["self", "func", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.apply_linear_mapping", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.apply_linear_mapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "matrix", "rhs", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.apply_linear_inverse", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.apply_linear_inverse", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "matrix", "solver", "rhs", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.simplify", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.simplify", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "rhs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.gradient", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.gradient", "type": "function", "doc": "<p>Computes the gradient of the scalar spAD2 variable a</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.hessian", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.hessian", "type": "function", "doc": "<p>Returns the hessian operator associated with the scalar spAD2 variable a</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.to_inputshapes", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.to_inputshapes", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.output", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.output", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.empty", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "empty", "type": "function", "doc": "<p></p>\n", "parameters": ["inputs", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.operator_like", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "operator_like", "type": "function", "doc": "<p>Operator_like reverseAD2 (or Reverse depending on reverse mode): </p>\n\n<ul>\n<li>should not register new inputs (conflicts with the way dir_hessian is provided)</li>\n<li>fixed co_output </li>\n<li>gets dir_hessian from inputs</li>\n</ul>\n", "parameters": ["inputs", "co_output", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD", "type": "class", "doc": "<p>A class for sparse forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.__init__", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef", "index", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.order", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.copy", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.as_tuple", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.as_func", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h, if specified.</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.compose", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.size_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.reshape", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.pad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.transpose", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.sum", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.bound_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.bound_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.to_dense", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.to_dense", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dense_size_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.triplets", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.triplets", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.tangent_operator", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.tangent_operator", "type": "function", "doc": "<p>Opaque matrix class representing the tangent linear operator</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.adjoint_operator", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.adjoint_operator", "type": "function", "doc": "<p>Opaque matrix class representing the adjoint linear operator</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.solve", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.solve", "type": "function", "doc": "<p>Assume that the spAD instance represents the variable y = x + A<em>delta,\nwhere delta is a symbolic perturbation. \nSolves the system x + A</em>delta = 0, assuming compatible shapes.</p>\n", "parameters": ["self", "raw"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.is_elliptic", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.is_elliptic", "type": "function", "doc": "<p>Tests wether the variable encodes a (linear) degenerate elliptic scheme.\nOutput :</p>\n\n<ul>\n<li>sum of the coefficients at each position (must be non-negative for \ndegenerate ellipticity, positive for strict ellipticity)</li>\n<li>maximum of off-diagonal coefficients at each position (must be non-positive)\nOutput (if tol is specified) : </li>\n<li>min_sum &gt;=-tol and max_off &lt;= tol\nSide effect warning : AD simplification, which is also possibly costly</li>\n</ul>\n", "parameters": ["self", "tol", "identity_var"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.concatenate", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.simplify_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.simplify_ad", "type": "function", "doc": "<p>Compresses the AD information by merging suitable coefficients, and optionally \nremoving negligible ones.</p>\n\n<ul>\n<li>atol : absolute tolerance to discard a coefficient. (True -> sensible default.)</li>\n<li>rtol : relative tolerance to discard a coefficient (compared to largest in row)</li>\n</ul>\n", "parameters": ["self", "atol", "rtol"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.cupy_variant", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.cupy_variant", "type": "class", "doc": "<p>A class for sparse forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.identity", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "identity", "type": "function", "doc": "<p></p>\n", "parameters": ["shape", "constant", "shift"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.register", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "register", "type": "function", "doc": "<p></p>\n", "parameters": ["inputs", "iterables", "shift", "ident"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy", "type": "class", "doc": "<p>A class for sparse forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.__init__", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef", "index", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.order", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.copy", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.as_tuple", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.as_func", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h, if specified.</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.compose", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.size_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.size_ad", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.reshape", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.pad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.transpose", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.sum", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.bound_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.bound_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.to_dense", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.to_dense", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dense_size_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.triplets", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.triplets", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.tangent_operator", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.tangent_operator", "type": "function", "doc": "<p>Opaque matrix class representing the tangent linear operator</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.adjoint_operator", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.adjoint_operator", "type": "function", "doc": "<p>Opaque matrix class representing the adjoint linear operator</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.solve", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.solve", "type": "function", "doc": "<p>Assume that the spAD instance represents the variable y = x + A<em>delta,\nwhere delta is a symbolic perturbation. \nSolves the system x + A</em>delta = 0, assuming compatible shapes.</p>\n", "parameters": ["self", "raw"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.is_elliptic", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.is_elliptic", "type": "function", "doc": "<p>Tests wether the variable encodes a (linear) degenerate elliptic scheme.\nOutput :</p>\n\n<ul>\n<li>sum of the coefficients at each position (must be non-negative for \ndegenerate ellipticity, positive for strict ellipticity)</li>\n<li>maximum of off-diagonal coefficients at each position (must be non-positive)\nOutput (if tol is specified) : </li>\n<li>min_sum &gt;=-tol and max_off &lt;= tol\nSide effect warning : AD simplification, which is also possibly costly</li>\n</ul>\n", "parameters": ["self", "tol", "identity_var"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.concatenate", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.simplify_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.simplify_ad", "type": "function", "doc": "<p>Compresses the AD information by merging suitable coefficients, and optionally \nremoving negligible ones.</p>\n\n<ul>\n<li>atol : absolute tolerance to discard a coefficient. (True -> sensible default.)</li>\n<li>rtol : relative tolerance to discard a coefficient (compared to largest in row)</li>\n</ul>\n", "parameters": ["self", "atol", "rtol"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD_cupy.numpy_variant", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD_cupy.numpy_variant", "type": "class", "doc": "<p>A class for sparse forward automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.new", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "new", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef", "index", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2", "type": "class", "doc": "<p>A class for sparse forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.__init__", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef1", "index", "coef2", "index_row", "index_col", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.order", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.copy", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.as_tuple", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.as_func", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.compose", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.size_ad1", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.size_ad1", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.size_ad2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.size_ad2", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.reshape", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.pad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.transpose", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.sum", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.bound_ad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.bound_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.to_dense", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.to_dense", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dense_size_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.to_first", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.to_first", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.triplets", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.triplets", "type": "function", "doc": "<p>The hessian operator, presented as triplets</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.hessian_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.hessian_operator", "type": "function", "doc": "<p>The hessian operator, presented as an opaque matrix class, supporting mul.\nImplicitly sums over all axes. Recommendation : apply simplify_ad before call.</p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.tangent_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.tangent_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.adjoint_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.adjoint_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.solve_stationnary", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.solve_stationnary", "type": "function", "doc": "<p>Finds a stationnary point to a quadratic function, provided as a spAD2 array scalar. \nUse \"raw = True\" to obtain the raw linear system and use your own solver.</p>\n", "parameters": ["self", "raw"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.solve_weakform", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.solve_weakform", "type": "function", "doc": "<p>Assume that a spAD2 array scalar represents the quadratic function\nQ(u,v) = a0 + a1.(u,v) + (u,v).a2.(u,v) of the variable (u,v).\nFinds u such that Q(u,v) is independent of v.\nUse \"raw = True\" to obtain the raw linear system and use your own solver.</p>\n", "parameters": ["self", "raw"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.concatenate", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.simplify_ad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.simplify_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.cupy_variant", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.cupy_variant", "type": "class", "doc": "<p>A class for sparse forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.identity", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "identity", "type": "function", "doc": "<p></p>\n", "parameters": ["args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.register", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "register", "type": "function", "doc": "<p></p>\n", "parameters": ["args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy", "type": "class", "doc": "<p>A class for sparse forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.__init__", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef1", "index", "coef2", "index_row", "index_col", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.order", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.order", "type": "function", "doc": "<p></p>\n", "parameters": ["cls"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.copy", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.as_tuple", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.as_tuple", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.as_func", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.as_func", "type": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.compose", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.compose", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "a", "t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.size_ad1", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.size_ad1", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.size_ad2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.size_ad2", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.reshape", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.reshape", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "order"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.broadcast_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.pad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.pad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pad_width", "args", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.transpose", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.transpose", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axes"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.sum", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "axis", "out", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.bound_ad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.bound_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.to_dense", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.to_dense", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dense_size_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.to_first", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.to_first", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.triplets", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.triplets", "type": "function", "doc": "<p>The hessian operator, presented as triplets</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.hessian_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.hessian_operator", "type": "function", "doc": "<p>The hessian operator, presented as an opaque matrix class, supporting mul.\nImplicitly sums over all axes. Recommendation : apply simplify_ad before call.</p>\n", "parameters": ["self", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.tangent_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.tangent_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.adjoint_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.adjoint_operator", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.solve_stationnary", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.solve_stationnary", "type": "function", "doc": "<p>Finds a stationnary point to a quadratic function, provided as a spAD2 array scalar. \nUse \"raw = True\" to obtain the raw linear system and use your own solver.</p>\n", "parameters": ["self", "raw"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.solve_weakform", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.solve_weakform", "type": "function", "doc": "<p>Assume that a spAD2 array scalar represents the quadratic function\nQ(u,v) = a0 + a1.(u,v) + (u,v).a2.(u,v) of the variable (u,v).\nFinds u such that Q(u,v) is independent of v.\nUse \"raw = True\" to obtain the raw linear system and use your own solver.</p>\n", "parameters": ["self", "raw"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.concatenate", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.concatenate", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "elems", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.simplify_ad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.simplify_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2_cupy.numpy_variant", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2_cupy.numpy_variant", "type": "class", "doc": "<p>A class for sparse forward second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.new", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "new", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "coef1", "index", "coef2", "index_row", "index_col", "broadcast_ad"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.adtype", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "adtype", "type": "function", "doc": "<p>Returns None if no ad variable found, or the adtype if one is found.\nAlso checks consistency of the ad types.</p>\n", "parameters": ["data", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.precision", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "precision", "type": "function", "doc": "<p>Precision of the floating point type of x.</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.remove_ad", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "remove_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["data", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.common_cast", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "common_cast", "type": "function", "doc": "<p>If any of the arguments is an AD type, casts all other arguments to that type.\nCasts to ndarray if no argument is an AD type. \nUsage : if a and b may or may not b AD arrays, \na,b = common_cast(a,b); a[0]=b[0]</p>\n", "parameters": ["args"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.min_argmin", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "min_argmin", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.max_argmax", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "max_argmax", "type": "function", "doc": "<p></p>\n", "parameters": ["array", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.apply_linear_mapping", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "apply_linear_mapping", "type": "function", "doc": "<p>Applies the provided linear operator, to a dense AD variable of first or second order.</p>\n", "parameters": ["matrix", "rhs", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.apply_linear_inverse", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "apply_linear_inverse", "type": "function", "doc": "<p>Applies the provided linear inverse to a dense AD variable of first or second order.</p>\n", "parameters": ["solver", "matrix", "rhs", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.squeeze_shape", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "squeeze_shape", "type": "function", "doc": "<p></p>\n", "parameters": ["shape", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.expand_shape", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "expand_shape", "type": "function", "doc": "<p></p>\n", "parameters": ["shape", "axis"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.disassociate", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "disassociate", "type": "function", "doc": "<p>Turns an array of shape shape_free + shape_bound \ninto an array of shape shape_free whose elements \nare arrays of shape shape_bound.\nTypical usage : recursive automatic differentiation.\nCaveat : by defaut, singleton dimensions are introduced \nto avoid numpy's \"clever\" treatment of scalar arrays.</p>\n\n<p>Arguments: </p>\n\n<ul>\n<li>array : reshaped array</li>\n<li>(optional) shape_free, shape_bound : outer and inner array shapes. One is deduced from the other.</li>\n<li>(optional) expand_free_dims, expand_bound_dims.</li>\n</ul>\n", "parameters": ["array", "shape_free", "shape_bound", "expand_free_dims", "expand_bound_dims"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.associate", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "associate", "type": "function", "doc": "<p>Turns an array of shape shape_free, whose elements \nare arrays of shape shape_bound, into an array \nof shape shape_free+shape_bound.\nInverse opeation to disassociate.</p>\n", "parameters": ["array", "squeeze_free_dims", "squeeze_bound_dims"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific", "modulename": "agd.AutomaticDifferentiation.ad_specific", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific.simplify_ad", "modulename": "agd.AutomaticDifferentiation.ad_specific", "qualname": "simplify_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific.apply", "modulename": "agd.AutomaticDifferentiation.ad_specific", "qualname": "apply", "type": "function", "doc": "<p>Applies the function to the given arguments, with special treatment if the following \nkeywords : </p>\n\n<ul>\n<li>envelope : take advantage of the envelope theorem, to differentiate a min or max.\nThe function is called twice, first without AD, then with AD and the oracle parameter.</li>\n<li>shape_bound : take advantage of dense-sparse (or dense-dense) AD composition to \ndifferentiate the function efficiently. The function is called with dense AD, and \nthe dimensions in shape_bound are regarded as a simple scalar.</li>\n<li>reverse_history : use the provided reverse AD trace.</li>\n</ul>\n", "parameters": ["f", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific.compose", "modulename": "agd.AutomaticDifferentiation.ad_specific", "qualname": "compose", "type": "function", "doc": "<p>Compose ad types, mostly intended for dense a and sparse b</p>\n", "parameters": ["a", "t", "shape_bound"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "", "type": "module", "doc": "<p>This file implements functionalities needed to make the agd library generic to cupy/numpy usage.\nIt does not import cupy, unless absolutely required.</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.get_array_module", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "get_array_module", "type": "function", "doc": "<p>Returns the cupy module or the numpy module, depending on data</p>\n", "parameters": ["data", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.samesize_int_t", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "samesize_int_t", "type": "function", "doc": "<p>Returns an integer type of the same size (32 or 64 bits) as a given float type</p>\n", "parameters": ["float_t"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_get", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_get", "type": "function", "doc": "<p>If argument is a cupy ndarray, returns output of 'get' member function, \nwhich is a numpy ndarray. Likewise for AD types. Returns unchanged argument otherwise.</p>\n\n<ul>\n<li>dtype64 : convert 32 bit floats and ints to their 64 bit counterparts</li>\n</ul>\n", "parameters": ["x", "dtype64", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_set", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_set", "type": "function", "doc": "<p>If argument is a numpy ndarray, converts it to a cupy ndarray. Applies to AD Types.</p>\n\n<ul>\n<li>dtype32 : convert 64 bit floats and ints to their 32 bit counterparts</li>\n</ul>\n", "parameters": ["x", "dtype32", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_get_args", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_get_args", "type": "function", "doc": "<p>Decorator applying cupy_get to all arguments of the given function.</p>\n\n<ul>\n<li><em>args, *</em>kwargs : passed to cupy_get</li>\n</ul>\n", "parameters": ["f", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.has_dtype", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "has_dtype", "type": "function", "doc": "<p>Wether one member of args is an ndarray with the provided dtype.</p>\n", "parameters": ["arg", "dtype", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.get_float_t", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "get_float_t", "type": "function", "doc": "<p>Returns float32 if found in any argument, else float64.</p>\n\n<ul>\n<li>kwargs : passed to has_dtype</li>\n</ul>\n", "parameters": ["arg", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.array_float_caster", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "array_float_caster", "type": "function", "doc": "<p>returns lambda arr : xp.asarray(arr,dtype=float_t) \nwhere xp and float_t are in consistency with the arguments.</p>\n", "parameters": ["arg", "kwargs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.set_output_dtype32", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "set_output_dtype32", "type": "function", "doc": "<p>If the output of the given funtion contains ndarrays with 64bit dtype,\nint or float, they are converted to 32 bit dtype.</p>\n", "parameters": ["f", "silent", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_friendly", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_friendly", "type": "function", "doc": "<p>Returns a \"cupy-friendly\" copy of the input module, function, or object,\nfollowing arbitrary and ad-hoc rules.</p>\n", "parameters": ["arg"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_support", "modulename": "agd.AutomaticDifferentiation.cupy_support", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.cupy_support.flat", "modulename": "agd.AutomaticDifferentiation.cupy_support", "qualname": "flat", "type": "function", "doc": "<p></p>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.functional.from_generator", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "from_generator", "type": "function", "doc": "<p>Returns the method for constructing an object from a generator.</p>\n", "parameters": ["iterable_type"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.rec_iter", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "rec_iter", "type": "function", "doc": "<p>Iterate recursively over x. \nIn the case of dictionnaries, if specified among the iterables, one iterates over values.</p>\n", "parameters": ["x", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.pair", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "pair", "type": "class", "doc": "<p>A two element iterable. \nIntroduced as an alternative of tuple, to avoid confusion in map_iterables</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.functional.pair.__init__", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "pair.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "first", "second"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.dict_like", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "dict_like", "type": "function", "doc": "<p>Wether a, type or instance, has 'items' attribute. \nWill be regarded as dict-like structure.</p>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.map_iterables", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "map_iterables", "type": "function", "doc": "<p>Apply f to variable 'a' exploring recursively certain iterables</p>\n", "parameters": ["f", "a", "iterables", "split"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.map_iterables2", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "map_iterables2", "type": "function", "doc": "<p>Apply f to variable 'a' and 'b' zipped, exploring recursively certain iterables</p>\n", "parameters": ["f", "a", "b", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.recurse", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "recurse", "type": "function", "doc": "<p></p>\n", "parameters": ["step", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.decorator_with_arguments", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "decorator_with_arguments", "type": "function", "doc": "<p>Decorator intended to simplify writing decorators with arguments. \n(In addition to the decorated function itself.)</p>\n", "parameters": ["decorator"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.decorate_module_functions", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "decorate_module_functions", "type": "function", "doc": "<p>Decorate the functions of a module.\nInputs : </p>\n\n<ul>\n<li>module : whose functions must be decorated</li>\n<li>decorator : to be applied</li>\n<li>copy_module : create a shallow copy of the module</li>\n<li>fct_names (optional) : list of functions to be decorated.\nIf unspecified, all functions, builtin functions, and builtin methods, are decorated.</li>\n</ul>\n", "parameters": ["module", "decorator", "copy_module", "fct_names", "ret_decorated"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.func_except_alt", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "func_except_alt", "type": "function", "doc": "<p>Returns a callable which evaluates func, but falls back to alt if exception is caught.</p>\n", "parameters": ["func", "exception", "alt"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.class_rebase", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "class_rebase", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "bases", "rebased_name"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.misc.normalize_axis", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "normalize_axis", "type": "function", "doc": "<p></p>\n", "parameters": ["axis", "ndim", "allow_tuple"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.add_ndim", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "add_ndim", "type": "function", "doc": "<p></p>\n", "parameters": ["arr", "n"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.key_expand", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "key_expand", "type": "function", "doc": "<p>Modifies a key to access an array with more dimensions. Needed if ellipsis is used.</p>\n", "parameters": ["key", "depth"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "apply_linear_operator", "type": "function", "doc": "<p>Applies a linear operator to an array with more than two dimensions,\nby flattening the last dimensions</p>\n", "parameters": ["op", "rhs", "flatten_ndim"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.ready_ad", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "ready_ad", "type": "function", "doc": "<p>Readies a variable for adding ad information, if possible.\nReturns : readied variable, boolean (wether AD extension is possible)</p>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.register", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "register", "type": "function", "doc": "<p></p>\n", "parameters": ["identity", "data", "iterables"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.sumprod", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "sumprod", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "v", "iterables", "to_first"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.reverse_mode", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "reverse_mode", "type": "function", "doc": "<p></p>\n", "parameters": ["co_output"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.recurse", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "recurse", "type": "function", "doc": "<p></p>\n", "parameters": ["step", "niter"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.as_flat", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "as_flat", "type": "function", "doc": "<p></p>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.tocsr", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "tocsr", "type": "function", "doc": "<p>Turns sparse matrix given as triplets into a csr (compressed sparse row) matrix</p>\n", "parameters": ["triplets", "shape"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.spsolve", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "spsolve", "type": "function", "doc": "<p>Solves a sparse linear system where the matrix is given as triplets.</p>\n", "parameters": ["triplets", "rhs"], "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.spapply", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "spapply", "type": "function", "doc": "<p>Applies a sparse matrix, given as triplets, to an rhs.</p>\n", "parameters": ["triplets", "rhs", "crop_rhs"], "funcdef": "def"}, {"fullname": "agd.Domain", "modulename": "agd.Domain", "qualname": "", "type": "module", "doc": "<p>This module allows to define domains of $R^d$ by combinations of elementary shapes, \nand to compute finite differences within these domains with Dirichlet boundary conditions.</p>\n"}, {"fullname": "agd.Domain.Domain", "modulename": "agd.Domain", "qualname": "Domain", "type": "class", "doc": "<p>This class represents a domain from which one can query \na level set function, the boundary distance in a given direction,\nand some related methods.</p>\n"}, {"fullname": "agd.Domain.Domain.__init__", "modulename": "agd.Domain", "qualname": "Domain.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Domain.Domain.level", "modulename": "agd.Domain", "qualname": "Domain.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.Domain.contains", "modulename": "agd.Domain", "qualname": "Domain.contains", "type": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.Domain.intervals", "modulename": "agd.Domain", "qualname": "Domain.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.Domain.freeway", "modulename": "agd.Domain", "qualname": "Domain.freeway", "type": "function", "doc": "<p>Output : Least $t\\geq 0$ such that $x+tv$ intersects the boundary.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.Domain.contains_ball", "modulename": "agd.Domain", "qualname": "Domain.contains_ball", "type": "function", "doc": "<p>Wether the domain contains the ball of center $x$ and radius $h$.\nApproximate predicate based on sampling, using ball_pattern.</p>\n", "parameters": ["self", "x", "h", "ball_pattern"], "funcdef": "def"}, {"fullname": "agd.Domain.Domain.ball_pattern", "modulename": "agd.Domain", "qualname": "Domain.ball_pattern", "type": "function", "doc": "<p>Produces a sampling pattern in a ball, to be used in the contains_ball predicate.</p>\n", "parameters": ["self", "vdim", "r"], "funcdef": "def"}, {"fullname": "agd.Domain.Domain.vdim", "modulename": "agd.Domain", "qualname": "Domain.vdim", "type": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.WholeSpace", "modulename": "agd.Domain", "qualname": "WholeSpace", "type": "class", "doc": "<p>This class represents the full space $R^d$.</p>\n"}, {"fullname": "agd.Domain.WholeSpace.level", "modulename": "agd.Domain", "qualname": "WholeSpace.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.WholeSpace.intervals", "modulename": "agd.Domain", "qualname": "WholeSpace.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.Ball", "modulename": "agd.Domain", "qualname": "Ball", "type": "class", "doc": "<p>This class represents a ball shaped domain.</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>center (optional), array : the center of the ball.</li>\n<li>radius (optional), scalar : the radius of the ball.\nDefaults to defining the unit two-dimensional ball.</li>\n</ul>\n"}, {"fullname": "agd.Domain.Ball.__init__", "modulename": "agd.Domain", "qualname": "Ball.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "center", "radius"], "funcdef": "def"}, {"fullname": "agd.Domain.Ball.vdim", "modulename": "agd.Domain", "qualname": "Ball.vdim", "type": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Ball.level", "modulename": "agd.Domain", "qualname": "Ball.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.Ball.intervals", "modulename": "agd.Domain", "qualname": "Ball.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.Box", "modulename": "agd.Domain", "qualname": "Box", "type": "class", "doc": "<p>This class represents a box shaped domain in $R^k$, mathematically defined \nas the product\n$$\n        [a_1,b_1] \\times ... \\times [a_k,b_k]\n$$\nof some intervals. </p>\n\n<p>__init__ argument : </p>\n\n<ul>\n<li>sides (optional) : [[a1,b1], ..., [ak,bk]] the intervals defining the box.\nDefaults to defining the two dimensional unit square.</li>\n</ul>\n"}, {"fullname": "agd.Domain.Box.__init__", "modulename": "agd.Domain", "qualname": "Box.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "sides"], "funcdef": "def"}, {"fullname": "agd.Domain.Box.sides", "modulename": "agd.Domain", "qualname": "Box.sides", "type": "variable", "doc": "<p>The intervals $[[a_1,b_1], ..., [a_k,b_k]]$ defining the box.</p>\n"}, {"fullname": "agd.Domain.Box.center", "modulename": "agd.Domain", "qualname": "Box.center", "type": "variable", "doc": "<p>The center $[ (a_1+b_1)/2, ..., (a_k+b_k)/2 ]$ of the box.</p>\n"}, {"fullname": "agd.Domain.Box.edgelengths", "modulename": "agd.Domain", "qualname": "Box.edgelengths", "type": "variable", "doc": "<p>The edge lengths $[ b_1-a_1, ..., b_k-a_k ]$ of the box.</p>\n"}, {"fullname": "agd.Domain.Box.vdim", "modulename": "agd.Domain", "qualname": "Box.vdim", "type": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Box.level", "modulename": "agd.Domain", "qualname": "Box.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.Box.intervals", "modulename": "agd.Domain", "qualname": "Box.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement", "modulename": "agd.Domain", "qualname": "AbsoluteComplement", "type": "class", "doc": "<p>This class represents the complement $R^d \\setminus \\Omega$, in the entire space,\n of a given domain $\\Omega\\subset R^d$.</p>\n\n<p>__init__ argument: </p>\n\n<ul>\n<li>dom : Domain of which to take the complement.</li>\n</ul>\n"}, {"fullname": "agd.Domain.AbsoluteComplement.__init__", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dom"], "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement.vdim", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.vdim", "type": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.AbsoluteComplement.contains", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.contains", "type": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement.level", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement.freeway", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.freeway", "type": "function", "doc": "<p>Output : Least $t\\geq 0$ such that $x+tv$ intersects the boundary.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement.intervals", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.Intersection", "modulename": "agd.Domain", "qualname": "Intersection", "type": "class", "doc": "<p>This class represents an intersection of several subdomains.</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>*doms : domains to intersect.</li>\n</ul>\n"}, {"fullname": "agd.Domain.Intersection.__init__", "modulename": "agd.Domain", "qualname": "Intersection.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "doms"], "funcdef": "def"}, {"fullname": "agd.Domain.Intersection.vdim", "modulename": "agd.Domain", "qualname": "Intersection.vdim", "type": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Intersection.contains", "modulename": "agd.Domain", "qualname": "Intersection.contains", "type": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.Intersection.level", "modulename": "agd.Domain", "qualname": "Intersection.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.Intersection.intervals", "modulename": "agd.Domain", "qualname": "Intersection.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.Complement", "modulename": "agd.Domain", "qualname": "Complement", "type": "function", "doc": "<p>Relative complement $\\Omega_1 \\setminus \\Omega_2$ of two given domains \n$\\Omega_1,\\Omega_2 \\subset R^d$.</p>\n", "parameters": ["dom1", "dom2"], "funcdef": "def"}, {"fullname": "agd.Domain.Union", "modulename": "agd.Domain", "qualname": "Union", "type": "function", "doc": "<p>Union of several domains.</p>\n", "parameters": ["doms"], "funcdef": "def"}, {"fullname": "agd.Domain.Band", "modulename": "agd.Domain", "qualname": "Band", "type": "class", "doc": "<p>Defines a banded domain in space, in between two parallel hyperplanes.\n$$\n        l_b &lt; &lt; x,v> &lt; u_b,\n$$\nwhere $v \\in R^d$ is a direction, and $l_b,u_b$ are a lower bound and an upper bound.</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>direction : array of shape $(d,)$, where $d$ is the ambient space dimension.</li>\n<li>bounds : $[l_b, u_b]$, the lower bound and upper bound.</li>\n</ul>\n"}, {"fullname": "agd.Domain.Band.__init__", "modulename": "agd.Domain", "qualname": "Band.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "direction", "bounds"], "funcdef": "def"}, {"fullname": "agd.Domain.Band.vdim", "modulename": "agd.Domain", "qualname": "Band.vdim", "type": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Band.level", "modulename": "agd.Domain", "qualname": "Band.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.Band.intervals", "modulename": "agd.Domain", "qualname": "Band.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.ConvexPolygon", "modulename": "agd.Domain", "qualname": "ConvexPolygon", "type": "function", "doc": "<p>Defines a two dimensional <em>convex</em> polygonal domain from its vertices.</p>\n\n<p>__init__ arguments :</p>\n\n<ul>\n<li>pts : array of shape (2,n). The polygon vertices, given in trigonometric order.</li>\n</ul>\n", "parameters": ["pts"], "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform", "modulename": "agd.Domain", "qualname": "AffineTransform", "type": "class", "doc": "<p>Defines a domain which is the image of another domain\nby the affine transformation, \n$$\n        x' = A x + b\n$$</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li><code>mult</code> (optional) : the multiplier $A$, which is either a scalar or a matrix \nof shape $(d,d)$. (Defaults to the identity matrix.)</li>\n<li><code>shift</code> (optional) : the vector $b$. (Defaults to zero.)</li>\n<li><code>center</code> (optional) : reference point for the transformation. (Defaults to zero.)</li>\n</ul>\n"}, {"fullname": "agd.Domain.AffineTransform.__init__", "modulename": "agd.Domain", "qualname": "AffineTransform.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dom", "mult", "shift", "center"], "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.vdim", "modulename": "agd.Domain", "qualname": "AffineTransform.vdim", "type": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.AffineTransform.forward", "modulename": "agd.Domain", "qualname": "AffineTransform.forward", "type": "function", "doc": "<p>Forward affine transformation, from the original domain to the transformed one.</p>\n", "parameters": ["self", "x", "linear"], "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.reverse", "modulename": "agd.Domain", "qualname": "AffineTransform.reverse", "type": "function", "doc": "<p>Reverse affine transformation, from the transformed domain to the original one.</p>\n", "parameters": ["self", "x", "linear"], "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.contains", "modulename": "agd.Domain", "qualname": "AffineTransform.contains", "type": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.level", "modulename": "agd.Domain", "qualname": "AffineTransform.level", "type": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.intervals", "modulename": "agd.Domain", "qualname": "AffineTransform.intervals", "type": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.freeway", "modulename": "agd.Domain", "qualname": "AffineTransform.freeway", "type": "function", "doc": "<p>Output : Least $t\\geq 0$ such that $x+tv$ intersects the boundary.</p>\n", "parameters": ["self", "x", "v"], "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet", "modulename": "agd.Domain", "qualname": "Dirichlet", "type": "class", "doc": "<p>Implements Dirichlet boundary conditions.\nWhen computing finite differences, values queried outside the domain interior\nare replaced with values obtained on the boundary along the given direction.</p>\n\n<p>__init__ arguments :</p>\n\n<ul>\n<li>domain: geometrical description of the domain </li>\n<li>value: a scalar or map yielding the value of the boundary conditions</li>\n<li>grid: the cartesian grid. Ex: np.array(np.meshgrid(aX,aY,indexing='ij')) for suitable aX,aY</li>\n</ul>\n\n<ul>\n<li>interior (optional): the points regarded as interior to the domain. </li>\n<li><p>interior_radius (optional): sets\n    interior = domain.contains_ball(interior_radius)</p></li>\n<li><p>grid_values (optional): placeholder values to be used on the grid.\n    Either an array of values, or a function</p></li>\n</ul>\n\n<p>member fields : </p>\n\n<ul>\n<li>interior : mask for the discretization grid points inside the domain.</li>\n</ul>\n"}, {"fullname": "agd.Domain.Dirichlet.__init__", "modulename": "agd.Domain", "qualname": "Dirichlet.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "domain", "value", "grid", "interior_radius", "interior", "grid_values"], "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet.shape", "modulename": "agd.Domain", "qualname": "Dirichlet.shape", "type": "variable", "doc": "<p>The shape of the domain (discretization grid).</p>\n"}, {"fullname": "agd.Domain.Dirichlet.vdim", "modulename": "agd.Domain", "qualname": "Dirichlet.vdim", "type": "variable", "doc": "<p>The dimension of the vector space containing the domain.</p>\n"}, {"fullname": "agd.Domain.Dirichlet.as_field", "modulename": "agd.Domain", "qualname": "Dirichlet.as_field", "type": "function", "doc": "<p>Adds trailing dimensions, and broadcasts arr, if necessary,\nso that the shape ends with the domain shape.</p>\n", "parameters": ["self", "arr", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet.not_interior", "modulename": "agd.Domain", "qualname": "Dirichlet.not_interior", "type": "variable", "doc": "<p>Mask for the grid points outside the domain.</p>\n"}, {"fullname": "agd.Domain.Dirichlet.Mock", "modulename": "agd.Domain", "qualname": "Dirichlet.Mock", "type": "variable", "doc": "<p>Returns mock Dirichlet boundary conditions obtained by evaluating \nthe boundary condition outside the interior.</p>\n"}, {"fullname": "agd.Domain.Dirichlet.DiffUpwind", "modulename": "agd.Domain", "qualname": "Dirichlet.DiffUpwind", "type": "function", "doc": "<p>First order upwind finite differences of u, along the offsets direction. \nUses boundary values when needed.\nInput : </p>\n\n<ul>\n<li>u : array with the domain shape.</li>\n<li>offsets :  array of integers, with shape \n(vdim, n1,...,nk) or (vdim, n1,...,nk, shape) \nwhere vdim,shape is the ambient space dimension and domain shape, \nand n1,...,nk are arbitrary.</li>\n<li>reth (optional) : wether to return the grid scale used (differs from the \ngrid scale on the neighborhood of the boundary).</li>\n</ul>\n", "parameters": ["self", "u", "offsets", "reth"], "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet.DiffCentered", "modulename": "agd.Domain", "qualname": "Dirichlet.DiffCentered", "type": "function", "doc": "<p>Centered finite differences of u, along the offsets direction, \ncomputed using the second order accurate centered scheme.\nFalls back to upwind finite differences close to the boundary.</p>\n", "parameters": ["self", "u", "offsets"], "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet.Diff2", "modulename": "agd.Domain", "qualname": "Dirichlet.Diff2", "type": "function", "doc": "<p>Second order finite differences of u, along the offsets direction.\nSecond order accurate in the interior, \nbut only first order accurate at the boundary.</p>\n", "parameters": ["self", "u", "offsets"], "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet", "modulename": "agd.Domain", "qualname": "MockDirichlet", "type": "class", "doc": "<p>Implements a crude version of Dirichlet boundary conditions, \nwhere the boundary conditions are given on the full domain complement.</p>\n\n<p>(No geometrical computations involved.)</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>grid_values : the Dirichlet boundary conditions. \nPlease set to np.nan the values interior to domain.</li>\n<li>gridscale : the discretization grid scale.</li>\n<li>padding : the padding values to be used outside the discretization grid.</li>\n</ul>\n"}, {"fullname": "agd.Domain.MockDirichlet.__init__", "modulename": "agd.Domain", "qualname": "MockDirichlet.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "grid_values", "gridscale", "padding"], "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet.interior", "modulename": "agd.Domain", "qualname": "MockDirichlet.interior", "type": "variable", "doc": "<p>The discretization grid points inside the domain.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.not_interior", "modulename": "agd.Domain", "qualname": "MockDirichlet.not_interior", "type": "variable", "doc": "<p>The discretization grid points outside the domain.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.vdim", "modulename": "agd.Domain", "qualname": "MockDirichlet.vdim", "type": "variable", "doc": "<p>The dimension of the vector space containing the domain.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.shape", "modulename": "agd.Domain", "qualname": "MockDirichlet.shape", "type": "variable", "doc": "<p>The shape of the domain discretization grid.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.as_field", "modulename": "agd.Domain", "qualname": "MockDirichlet.as_field", "type": "function", "doc": "<p>Adds trailing dimensions, and broadcasts arr, if necessary,\nso that the shape ends with the discretization grid shape.</p>\n", "parameters": ["self", "arr", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet.DiffUpwind", "modulename": "agd.Domain", "qualname": "MockDirichlet.DiffUpwind", "type": "function", "doc": "<p>First order upwind finite differences of u, along the offsets direction. \nUses grid_values outside the domain interior.</p>\n", "parameters": ["self", "u", "offsets", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet.DiffCentered", "modulename": "agd.Domain", "qualname": "MockDirichlet.DiffCentered", "type": "function", "doc": "<p>First order centered finite differences of u, along the offsets direction. \nUses grid_values outside the domain interior.</p>\n", "parameters": ["self", "u", "offsets"], "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet.Diff2", "modulename": "agd.Domain", "qualname": "MockDirichlet.Diff2", "type": "function", "doc": "<p>Second order order finite differences of u, along the offsets direction. \nUses grid_values outside the domain interior.</p>\n", "parameters": ["self", "u", "offsets", "args"], "funcdef": "def"}, {"fullname": "agd.Eikonal", "modulename": "agd.Eikonal", "qualname": "", "type": "module", "doc": "<p>The Eikonal package embeds CPU and GPU numerical solvers of (generalized) eikonal \nequations. These are variants of the fast marching and fast sweeping method, based on \nsuitable discretizations of the PDE, and written and C++.</p>\n\n<p>Please see the illustrative notebooks for detailed usage instructions and examples:\nhttps://github.com/Mirebeau/AdaptiveGridDiscretizations</p>\n\n<p>Main object : </p>\n\n<ul>\n<li>dictIn : a dictionary-like structure, used to gathers the arguments of the \neikonal solver, and eventually call it.</li>\n</ul>\n"}, {"fullname": "agd.Eikonal.VoronoiDecomposition", "modulename": "agd.Eikonal", "qualname": "VoronoiDecomposition", "type": "function", "doc": "<p>Calls the FileVDQ library to decompose the provided quadratic form(s),\nas based on Voronoi's first reduction of quadratic forms.</p>\n\n<ul>\n<li>mode : 'cpu' or 'gpu' or 'gpu_transfer'. \nDefaults to VoronoiDecomposition.default_mode if specified, or to gpu/cpu adequately.</li>\n<li>args,kwargs : passed to gpu decomposition method</li>\n</ul>\n", "parameters": ["arr", "mode", "steps", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn", "modulename": "agd.Eikonal.DictIn", "qualname": "", "type": "module", "doc": "<p>The Eikonal.dictIn class is used to hold the input parameters to the eikonal solvers of \nthe HFM library, CPU based or GPU based.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictOut", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut", "type": "class", "doc": "<p>A dictionnary like structure used as output of the Eikonal solvers.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictOut.__init__", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "store"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictOut.copy", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictOut.keys", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut.keys", "type": "function", "doc": "<p>The keys of the dictionary-like structure.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.CenteredLinspace", "modulename": "agd.Eikonal.DictIn", "qualname": "CenteredLinspace", "type": "function", "doc": "<p>Returns a linspace shifted by half a node length.\nInputs : </p>\n\n<ul>\n<li>a,b : interval endpoints</li>\n<li>n : number of points</li>\n</ul>\n", "parameters": ["a", "b", "n"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn", "type": "class", "doc": "<p>A dictionary like structure used as input of the Eikonal solvers.</p>\n\n<p>__init__ arguments: </p>\n\n<ul>\n<li>store : a dictionary, used for initialization.</li>\n</ul>\n\n<p>See dictIn().RunHelp() for details on the eikonal solver inputs.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.__init__", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "store"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.default_mode", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.default_mode", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.copy", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.copy", "type": "function", "doc": "<p>Returns a shallow copy of the structure.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.mode", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.mode", "type": "variable", "doc": "<p>The running mode of the eikonal solver, see the Run method.\nThe input data must be provided using a compatible array module: \nnumpy in 'cpu' mode, cupy in 'gpu' mode.</p>\n\n<p>Supported running mode for the eikonal solver : </p>\n\n<ul>\n<li>'cpu' : Run algorithm on host, store data on host</li>\n<li>'cpu_transfer' : Run algorithm on host, store data on device</li>\n<li>'cpu_raw' : Raw call to the HFM CPU library (debug purposes)</li>\n<li>'gpu' : Run algorithm on device, store data on device</li>\n<li>'gpu_transfer' : Run algorithm on device, store data on host</li>\n</ul>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.float_t", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.float_t", "type": "variable", "doc": "<p>The floating point type of the data arrays. Typically np.float64 in 'cpu' mode, \nand np.float32 in 'gpu' mode.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.keys", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.keys", "type": "function", "doc": "<p>The keys of this dictionary structure.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.RunHelp", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.RunHelp", "type": "function", "doc": "<p>Help on the eikonal solver, depending on the running mode.</p>\n", "parameters": ["self", "mode"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.Run", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.Run", "type": "function", "doc": "<p>Calls the HFM library, prints log and returns output.\nInputs : </p>\n\n<ul>\n<li>join (optional) : join the dictionary with these additional entries before running.</li>\n<li>**kwargs (optional) : passed to the run_detail.RunSmart or HFM_CUDA.RunGPU methods.</li>\n</ul>\n\n<p>See dictIn().RunHelp() for additional details, depending on the running mode.</p>\n", "parameters": ["self", "join", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.shape", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.shape", "type": "variable", "doc": "<p>The shape of the discretization grid.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.size", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.size", "type": "variable", "doc": "<p>The number of points in the discretization grid.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SE", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SE", "type": "variable", "doc": "<p>Wether the model is based on the Special Euclidean group.\nTrue for curvature penalized models.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.vdim", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.vdim", "type": "variable", "doc": "<p>The dimension of the ambient vector space.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.nTheta", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.nTheta", "type": "variable", "doc": "<p>Number of points for discretizing the interval [0,2 pi], in the angular space \ndiscretization, for the SE models (a.k.a. curvature penalized models).</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.gridScales", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.gridScales", "type": "variable", "doc": "<p>The discretization grid scale along each axis.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.corners", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.corners", "type": "variable", "doc": "<p>Returns the extreme points grid[:,0,...,0] and grid[:,-1,...,-1] of the \ndiscretization grid.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.Axes", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.Axes", "type": "function", "doc": "<p>The discretization points used along each coordinate axis.</p>\n", "parameters": ["self", "dims"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.Grid", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.Grid", "type": "function", "doc": "<p>Returns a grid of coordinates, containing all the discretization points of the domain.\nSimilar to np.meshgrid(*self.Axes(),indexing='ij')\nInputs : </p>\n\n<ul>\n<li>dims(optional) : use a different sampling of the domain</li>\n</ul>\n", "parameters": ["self", "dims"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetUniformTips", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetUniformTips", "type": "function", "doc": "<p>Place regularly spaced tip points all over the domain, \nfrom which to backtrack minimal geodesics.\nInputs : </p>\n\n<ul>\n<li>dims : number of tips to use along each dimension.</li>\n</ul>\n", "parameters": ["self", "dims"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetRect", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetRect", "type": "function", "doc": "<p>Defines a box domain, for the HFM library.\nInputs:</p>\n\n<ul>\n<li>sides, e.g. ((a,b),(c,d),(e,f)) for the domain [a,b]x[c,d]x[e,f]</li>\n<li>sampleBoundary : switch between sampling at the pixel centers, and sampling including the boundary</li>\n<li>gridScale, gridScales : side h>0 of each pixel (alt : axis dependent)</li>\n<li>dimx, dims : number of points along the first axis (alt : along all axes)</li>\n</ul>\n", "parameters": ["self", "sides", "sampleBoundary", "gridScale", "gridScales", "dimx", "dims"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.PointFromIndex", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.PointFromIndex", "type": "function", "doc": "<p>Turns an index into a point.\nOptional argument to: if true, inverse transformation, turning a point into a continuous index</p>\n", "parameters": ["self", "index", "to"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.IndexFromPoint", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.IndexFromPoint", "type": "function", "doc": "<p>Returns the index that yields the position closest to a point, and the error.</p>\n", "parameters": ["self", "point"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.OrientedPoints", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.OrientedPoints", "type": "function", "doc": "<p>Appends all possible orientations to the point coordinates.</p>\n", "parameters": ["self", "pointU"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.VectorFromOffset", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.VectorFromOffset", "type": "function", "doc": "<p>Turns a finite difference offset into a vector, by multiplying by the gridScale.\nInputs : </p>\n\n<ul>\n<li>offset : the offset to convert.</li>\n<li>to (optional) : if True, produces an offset from a vector (reverse operation).</li>\n</ul>\n", "parameters": ["self", "offset", "to"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.GridNeighbors", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.GridNeighbors", "type": "function", "doc": "<p>Returns the neighbors around a point on the grid. \nGeometry last convention\nInputs: </p>\n\n<ul>\n<li>point (array): geometry last</li>\n<li>gridRadius (scalar): given in pixels</li>\n</ul>\n", "parameters": ["self", "point", "gridRadius"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetFactor", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetFactor", "type": "function", "doc": "<p>This function setups additive factorization around the seeds.\nInputs (optional): </p>\n\n<ul>\n<li>radius.\n    Positive number -> approximate radius, in pixels, of source factorization.\n    -1 -> Factorization over all the domain. \n    None -> source factorization over all the domain</li>\n<li>value (optional).\ncallable, array -> approximate values of the solution. \nNone -> reconstructed from the metric.</li>\n<li>gradient (optional) \ncallable, array -> approximate gradient of the solution.\nObtained from the values by automatic differentiation if unspecified.</li>\n</ul>\n\n<p>Outputs : the subgrid used for factorization\nSide effect : sets 'factoringValues', 'factoringGradients', \n   and in the case of a subgrid 'factoringIndexShift'</p>\n", "parameters": ["self", "radius", "value", "gradient"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetSphere", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetSphere", "type": "function", "doc": "<p>Setups the manifold R^(d-k) x S^k, using the equatorial projection for the sphere S^k.\nOnly compatible with the GPU accelerated eikonal solver. \nInputs : \n        dimsp (int): the discretization of a half sphere involves dimsp^k pixels.\n        radius (optional, float &gt; 1): each local chart has base domain [-radius,radius]^k.\n          (This is NOT the radius of the sphere, which is 1, but of the parametrization.)\n        separation (optional, int) : number of pixels separating the two local charts.\n                Set to false to define a projective space using a single chart. \nSide effects : \n        Sets chart_mapping,chart_jump, dimensions, origin, gridScales.\nOutput : \n        - Conversion utilities, between the equatorial plane and the sphere \n                (and grid in the non-projective case)</p>\n", "parameters": ["self", "dimsp", "separation", "radius"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.factoringPointChoice", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.factoringPointChoice", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.DictIn_detail", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "", "type": "module", "doc": "<p>This file implements additional functionality of the Eikonal.dictIn class, related to \nsource factorization, and to solving PDEs on spheres.</p>\n"}, {"fullname": "agd.Eikonal.DictIn_detail.factoringPointChoice", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "factoringPointChoice", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.SetFactor", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "SetFactor", "type": "function", "doc": "<p>This function setups additive factorization around the seeds.\nInputs (optional): </p>\n\n<ul>\n<li>radius.\n    Positive number -> approximate radius, in pixels, of source factorization.\n    -1 -> Factorization over all the domain. \n    None -> source factorization over all the domain</li>\n<li>value (optional).\ncallable, array -> approximate values of the solution. \nNone -> reconstructed from the metric.</li>\n<li>gradient (optional) \ncallable, array -> approximate gradient of the solution.\nObtained from the values by automatic differentiation if unspecified.</li>\n</ul>\n\n<p>Outputs : the subgrid used for factorization\nSide effect : sets 'factoringValues', 'factoringGradients', \n   and in the case of a subgrid 'factoringIndexShift'</p>\n", "parameters": ["self", "radius", "value", "gradient"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.proj_tosphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "proj_tosphere", "type": "function", "doc": "<p>Maps a point of the equatorial plane to the sphere, by projection : \nx -> (2 x,1-|x\u220f^2)/(1+|x|^2)</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.proj_fromsphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "proj_fromsphere", "type": "function", "doc": "<p>Maps a point of the sphere to the equatorial plane, by projection.\n(q,qz) -> q/(1+qz)</p>\n", "parameters": ["q"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.sphere_tosphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "sphere_tosphere", "type": "function", "doc": "<p>See proj_tosphere. Last component is reversed according to chart.</p>\n", "parameters": ["x", "chart"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.sphere_fromsphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "sphere_fromsphere", "type": "function", "doc": "<p>See proj_fromsphere. Last component of q is reversed according to chart.</p>\n", "parameters": ["q", "chart"], "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.SetSphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "SetSphere", "type": "function", "doc": "<p>Setups the manifold R^(d-k) x S^k, using the equatorial projection for the sphere S^k.\nOnly compatible with the GPU accelerated eikonal solver. \nInputs : \n        dimsp (int): the discretization of a half sphere involves dimsp^k pixels.\n        radius (optional, float &gt; 1): each local chart has base domain [-radius,radius]^k.\n          (This is NOT the radius of the sphere, which is 1, but of the parametrization.)\n        separation (optional, int) : number of pixels separating the two local charts.\n                Set to false to define a projective space using a single chart. \nSide effects : \n        Sets chart_mapping,chart_jump, dimensions, origin, gridScales.\nOutput : \n        - Conversion utilities, between the equatorial plane and the sphere \n                (and grid in the non-projective case)</p>\n", "parameters": ["self", "dimsp", "separation", "radius"], "funcdef": "def"}, {"fullname": "agd.Eikonal.FileIO", "modulename": "agd.Eikonal.FileIO", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.FileIO.RawToFiles", "modulename": "agd.Eikonal.FileIO", "qualname": "RawToFiles", "type": "function", "doc": "<p>Exports a dictionary to a pair of files, whose name begins with 'prefix'.\nThe dictionnary elements must by strings, scalars, and numpy arrays.\nThe resulting files are readable by the HFM library.</p>\n", "parameters": ["params", "prefix"], "funcdef": "def"}, {"fullname": "agd.Eikonal.FileIO.FilesToRaw", "modulename": "agd.Eikonal.FileIO", "qualname": "FilesToRaw", "type": "function", "doc": "<p>Imports a pair of files, whose name begins with 'prefix', into a dictionary.\nThese files may be produced by the HFM library.</p>\n", "parameters": ["prefix"], "funcdef": "def"}, {"fullname": "agd.Eikonal.FileIO.WriteCallRead", "modulename": "agd.Eikonal.FileIO", "qualname": "WriteCallRead", "type": "function", "doc": "<p></p>\n", "parameters": ["inputData", "executable", "binary_dir", "working_dir", "inputPrefix", "outputPrefix"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA", "modulename": "agd.Eikonal.HFM_CUDA", "qualname": "", "type": "module", "doc": "<p>This package is implementation detail for a GPU accelerated eikonal solver. It should \nnot be used directly, but through the parent package. (Run method of the dictIn class,\nwith mode='gpu'.)</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.RunGPU", "modulename": "agd.Eikonal.HFM_CUDA", "qualname": "RunGPU", "type": "function", "doc": "<p>Runs the GPU eikonal solver.</p>\n\n<p>Main input:</p>\n\n<ul>\n<li>hfmIn : a dictionary like-structure</li>\n</ul>\n\n<p>The solver embeds some help information, which can be accessed as follows.</p>\n\n<ul>\n<li>set hfmIn['verbosity'] to 1 or 2 to display information on run, including the defaulted keys.\nset to 0 to silence the run.</li>\n<li>look at hfmOut['keys']['help'] to see a basic help regarding each key,\nwhere hfmOut is the output of this function.</li>\n</ul>\n", "parameters": ["hfmIn", "args", "cache", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.EikonalGPU_NotImplementedError", "modulename": "agd.Eikonal.HFM_CUDA", "qualname": "EikonalGPU_NotImplementedError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.EikonalGPU_NotImplementedError.__init__", "modulename": "agd.Eikonal.HFM_CUDA", "qualname": "EikonalGPU_NotImplementedError.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "message"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "", "type": "module", "doc": "<p>This file implements the linear elastic wave equation, with a generic Hooke tensor.\nReading \nDt q = Dp H - r q\nDt p = Dq H - r p \nwhere r is a damping factor, H is a separable quadratic Hamiltonian \nH(q,p) = A(grad q) + B(p)\nwhere A is the elastic potential energy, defined by the Hooke tensor, \nand B the kinetic energy, defined by the metric tensor.</p>\n\n<p>The operator DpH is \"differentiated then discretized\". Usually, \n\"discretize then differentiate\" methods are preferred, but here they are much more memory\nintensive (at least in three dimensions with the fourth order scheme).</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave", "type": "class", "doc": "<p>Warning : accessing this object's properties has a significant memory and \ncomputational cost, because all data is converted to a kernel friendly format.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.__init__", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shape", "traits", "periodic", "vertical_thres"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.float_t", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.float_t", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.int_t", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.int_t", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.offsetpack_t", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.offsetpack_t", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.order", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.order", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.periodic", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.periodic", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.isotropic_metric", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.isotropic_metric", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.shape", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.shape", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.shape_o", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.shape_o", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.shape_i", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.shape_i", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.size_o", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.size_o", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.size_i", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.size_i", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.vdim", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.vdim", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.symdim", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.symdim", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.decompdim", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.decompdim", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.vertical", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.vertical", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.vertical_kind", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.vertical_kind", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.vertical_thres", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.vertical_thres", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.offsetnbits", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.offsetnbits", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.voigt2lower", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.voigt2lower", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.block_expand", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.block_expand", "type": "function", "doc": "<p>Reshapes the array so as to factor shape_i. Also moves the geometry axis before\nshape_i, following the convention of HookeWave.h</p>\n", "parameters": ["self", "value", "constant_values", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.block_squeeze", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.block_squeeze", "type": "function", "doc": "<p>Inverse operation to block_expand</p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.weights", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.weights", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.offsets", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.offsets", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.hooke", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.hooke", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.set_hooke_cst", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.set_hooke_cst", "type": "function", "doc": "<p>Sets a constant hooke tensor over the domain</p>\n", "parameters": ["self", "hooke"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.set_hooke", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.set_hooke", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "hooke", "div_hooke"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.set_hooke_vertical", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.set_hooke_vertical", "type": "function", "doc": "<p>Sets a hooke tensor, using a vertical approximation where suitable.</p>\n", "parameters": ["self", "hooke", "div_hooke"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.metric", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.metric", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.damping", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.damping", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.dt", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.dt", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.gridScale", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.gridScale", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.SetCst", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.SetCst", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name", "value", "dtype"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.q", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.q", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.p", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.p", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.AdvanceP", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.AdvanceP", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.AdvanceQ", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.AdvanceQ", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.check", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.check", "type": "function", "doc": "<p>Check that all arguments have the correct type, shape, are not None, \nand are c-contiguous arrays</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.HookeWave.HookeWave.Advance", "modulename": "agd.Eikonal.HFM_CUDA.HookeWave", "qualname": "HookeWave.Advance", "type": "function", "doc": "<p>niter steps of the Verlet scheme, starting with a half step of q.</p>\n", "parameters": ["self", "dt", "niter"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "modulename": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "qualname": "", "type": "module", "doc": "<p>This module attempts to find the parameters of a TTI norm, given a hooke tensor.\nThis boils down to minimizing a polynomial over a sphere. We follow a naive approach, where\nNewton methods are started from a large number of points in the sphere, and the best result \nis selected. In principle however, SDP relaxation techniques are applicable.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.ProjectionTTI.ProjectionTTI", "modulename": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "qualname": "ProjectionTTI", "type": "function", "doc": "<p>Attempts to produce a TTI norm matching the given Hooke tensors.</p>\n\n<ul>\n<li>n_newton = number of Newton steps in the optimization.</li>\n<li>samples = seed points in unit sphere (or number of them)</li>\n</ul>\n", "parameters": ["hooke", "n_newton", "samples"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "modulename": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "qualname": "", "type": "module", "doc": "<p>This module solves the shape from shading PDE, with a non-vertical light source. \nThe PDE reads \n(alpha u_x + beta u_y + gamma) / sqrt(1+u_x^2+u_y^2) = rhs\nwhere alpha, beta, gamma are parameters related to the sun direction.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.ShapeFromShading.EvalScheme", "modulename": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "qualname": "EvalScheme", "type": "function", "doc": "<p>Evaluates the (piecewise) quadratic equation defining the numerical scheme.\nInputs :</p>\n\n<ul>\n<li>uc : plays the role of \u03bb</li>\n<li>params : alpha,beta,gamma,h (grid scale)</li>\n</ul>\n", "parameters": ["cp", "u", "params", "uc", "mask"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ShapeFromShading.Solve", "modulename": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "qualname": "Solve", "type": "function", "doc": "<p>Iterative solver for the shape from shading equation.</p>\n", "parameters": ["rhs", "mask", "u0", "params", "niter", "traits"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "modulename": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition.Reconstruct", "modulename": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "qualname": "Reconstruct", "type": "function", "doc": "<p></p>\n", "parameters": ["coefs", "offsets"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition.VoronoiDecomposition", "modulename": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "qualname": "VoronoiDecomposition", "type": "function", "doc": "<p>Returns the Voronoi decomposition of a family of quadratic forms. </p>\n\n<ul>\n<li>m : the (symmetric) matrices of the quadratic forms to decompose.</li>\n<li>offset_t : the type of offsets to be returned. </li>\n<li>flattened : wether the input matrices are flattened</li>\n<li>retry64_tol (optional) : retries decomposition using 64bit floats if this error \nis exceeded relative to matrix trace. (Set retry64_tol = 0 to use double precision.)</li>\n</ul>\n", "parameters": ["m", "offset_t", "flattened", "blockDim", "traits", "steps", "retry64_tol"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.getmtime_max", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "getmtime_max", "type": "function", "doc": "<p>Lists all the files in the given directory, and returns the last time one of them\nwas modified. Information needed when compiling cupy modules, because they are cached.</p>\n", "parameters": ["directory"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.GetModule", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "GetModule", "type": "function", "doc": "<p>Returns a cupy raw module</p>\n", "parameters": ["source", "cuoptions"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.SetModuleConstant", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "SetModuleConstant", "type": "function", "doc": "<p>Sets a global constant in a cupy cuda module.</p>\n", "parameters": ["module", "key", "value", "dtype"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.traits_header", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "traits_header", "type": "function", "doc": "<p>Returns the source (mostly a preamble) for the gpu kernel code \nfor the given traits.</p>\n\n<ul>\n<li>join (optional): return a multiline string, rather than a list of strings</li>\n<li>size_of_shape: insert traits for the size of each shape.</li>\n<li>log2_size: insert a trait for the ceil of the base 2 logarithm of previous size.</li>\n<li>integral_max: declare max of integral typedefs</li>\n</ul>\n", "parameters": ["traits", "join", "size_of_shape", "log2_size", "integral_max"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.graph_reverse", "modulename": "agd.Eikonal.HFM_CUDA.graph_reverse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.graph_reverse.graph_reverse", "modulename": "agd.Eikonal.HFM_CUDA.graph_reverse", "qualname": "graph_reverse", "type": "function", "doc": "<p>Inverses a weighted graph. </p>\n\n<ul>\n<li>invalid_index : special value to be ignored in fwd (defaults to Int_Max)</li>\n<li>nrev : expected max number of neighbors in reversed graph</li>\n<li>irev_t\nOutput : \n<ul>\n<li>rev, rev_weight. !! Warning : likely not contiguous arrays. !!</li>\n</ul></li>\n</ul>\n", "parameters": ["fwd", "fwd_weight", "invalid_index", "nrev", "blockDim"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.dtype_sup", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "dtype_sup", "type": "function", "doc": "<p></p>\n", "parameters": ["dtype"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.dtype_inf", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "dtype_inf", "type": "function", "doc": "<p></p>\n", "parameters": ["dtype"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.distance_kernel", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "distance_kernel", "type": "function", "doc": "<p></p>\n", "parameters": ["radius", "ndim", "dtype", "ord", "mult"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.inf_convolution", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "inf_convolution", "type": "function", "doc": "<p>Perform an inf convolution of an input with a given kernel, on the GPU.</p>\n\n<ul>\n<li>arr : the input array</li>\n<li>kernel : the convolution kernel. A centered kernel will be used.</li>\n<li>niter (optional) : number of iterations of the convolution.</li>\n<li>periodic (optional, bool or tuple of bool): axes using periodic boundary conditions.</li>\n<li>mix_is_min : if false, use sup_convolution instead</li>\n</ul>\n", "parameters": ["arr", "kernel", "out", "niter", "periodic", "upper_saturation", "lower_saturation", "mix_is_min", "overwrite", "block_size"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.kernel_traits", "modulename": "agd.Eikonal.HFM_CUDA.kernel_traits", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.kernel_traits.default_traits", "modulename": "agd.Eikonal.HFM_CUDA.kernel_traits", "qualname": "default_traits", "type": "function", "doc": "<p>Default traits of the GPU implementation of an HFM model.\n(self is an instance of the class Interface from file interface.py)\nSide effect : sets the default FIM front width. (None : AGSI is fine.)</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.kernel_traits.nscheme", "modulename": "agd.Eikonal.HFM_CUDA.kernel_traits", "qualname": "nscheme", "type": "function", "doc": "<p>Provides the structure of the finite difference scheme used.\n(number of symmmetric offsets, foward offsets, max or min of a number of schemes)</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.misc", "modulename": "agd.Eikonal.HFM_CUDA.misc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.misc.integral_largest_nextlargest", "modulename": "agd.Eikonal.HFM_CUDA.misc", "qualname": "integral_largest_nextlargest", "type": "function", "doc": "<p></p>\n", "parameters": ["dtype"], "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall", "modulename": "agd.Eikonal.LibraryCall", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.LibraryCall.SetInput", "modulename": "agd.Eikonal.LibraryCall", "qualname": "SetInput", "type": "function", "doc": "<p></p>\n", "parameters": ["hfm", "params"], "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.GetOutput", "modulename": "agd.Eikonal.LibraryCall", "qualname": "GetOutput", "type": "function", "doc": "<p></p>\n", "parameters": ["hfm"], "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.ListToNDArray", "modulename": "agd.Eikonal.LibraryCall", "qualname": "ListToNDArray", "type": "function", "doc": "<p></p>\n", "parameters": ["params"], "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.RunDispatch", "modulename": "agd.Eikonal.LibraryCall", "qualname": "RunDispatch", "type": "function", "doc": "<p></p>\n", "parameters": ["params", "bin_dir"], "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.GetBinaryDir", "modulename": "agd.Eikonal.LibraryCall", "qualname": "GetBinaryDir", "type": "function", "doc": "<p>This function is used due to the special way the HamiltonFastMarching library is used:</p>\n\n<ul>\n<li>as a bunch of command line executables, whose name begins with FileHFM.</li>\n<li>as a python library, named HFMpy</li>\n</ul>\n\n<p>The function will look for a file named \"FileHFM_binary_dir.txt\" (or a global variable named FileHFM_binary_dir)</p>\n\n<ul>\n<li>if it exists, the first line is read\n<ul>\n<li>if the first line is None -> use the HFMpy library</li>\n<li>otherwise, check that the first line is a valid directory -> should contain the FileHFM executables</li>\n</ul></li>\n<li>if file cannot be read -> use the HFMpy library</li>\n</ul>\n", "parameters": ["execName", "libName"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail", "modulename": "agd.Eikonal.run_detail", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.GetGeodesics", "modulename": "agd.Eikonal.run_detail", "qualname": "GetGeodesics", "type": "function", "doc": "<p></p>\n", "parameters": ["output", "suffix"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache", "type": "class", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.Cache.__init__", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "needsflow"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache.empty", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.empty", "type": "function", "doc": "<p>Wether the cache lacks data needed to bypass computation</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache.PreProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.PreProcess", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "hfmIn_raw"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache.PostProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.PostProcess", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "hfmOut_raw"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache.geodesicFlow", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.geodesicFlow", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "hfmIn"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.RunRaw", "modulename": "agd.Eikonal.run_detail", "qualname": "RunRaw", "type": "function", "doc": "<p>Raw call to the HFM library</p>\n", "parameters": ["hfmIn"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.RunSmart", "modulename": "agd.Eikonal.run_detail", "qualname": "RunSmart", "type": "function", "doc": "<p>Calls the HFM library, a CPU eikonal solver written in C++,\nwith pre-processing and post-processing of data.</p>\n\n<p>Main input : </p>\n\n<ul>\n<li>hfmIn, a dictionary like structure, containing the eikonal solver data.</li>\n</ul>\n\n<p>The C++ library embeds some help information, which can be accessed using the \nfollowing key:value pairs in hfmIn.</p>\n\n<ul>\n<li>'verbosity' : set to 1 or 2 to display information on run, including the defaulted keys.\nset to 0 to silence the run.</li>\n<li>'keyHelp' : set as a string of keys separated by spaces, to print help on these.\nexample 'keyHelp':\"seeds tips\"</li>\n</ul>\n\n<p>Optional input:</p>\n\n<ul>\n<li>co_output (optional) : used for reverse automatic differentiation.</li>\n<li>cache (optional) : store some intermediate results to bypass computations at a later stage. </li>\n<li>returns (optional) : early aborts the run (debug purposes). ('in_raw','out_raw','out')</li>\n</ul>\n", "parameters": ["hfmIn", "co_output", "cache", "returns"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.setkey_safe", "modulename": "agd.Eikonal.run_detail", "qualname": "setkey_safe", "type": "function", "doc": "<p></p>\n", "parameters": ["dico", "key", "value"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.flow_variation", "modulename": "agd.Eikonal.run_detail", "qualname": "flow_variation", "type": "function", "doc": "<p></p>\n", "parameters": ["flow", "metric"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.PreProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "PreProcess", "type": "function", "doc": "<p>copies key,val from refined to raw, with adequate treatment</p>\n", "parameters": ["key", "value", "refined_in", "raw_out", "cache"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.PostProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "PostProcess", "type": "function", "doc": "<p>copies key,val from raw to refined, with adequate treatment</p>\n", "parameters": ["key", "value", "raw_in", "refined_out"], "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.CastOffsets", "modulename": "agd.Eikonal.run_detail", "qualname": "CastOffsets", "type": "function", "doc": "<p>Offsets are exported with their coefficients bundled together in a double.\nThis function unpacks them.</p>\n", "parameters": ["raw_offsets"], "funcdef": "def"}, {"fullname": "agd.ExportedCode", "modulename": "agd.ExportedCode", "qualname": "", "type": "module", "doc": "<p>This is not really a package, but a collection of code samples automatically extracted \nfrom the illustrative notebooks of the AGD library:\nhttps://github.com/Mirebeau/AdaptiveGridDiscretizations</p>\n\n<p>These code samples use in several notebooks. Yet they are too specific and narrow focused \nto be integrated in the base of AGD library.</p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo", "modulename": "agd.ExportedCode.Notebooks_Algo", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.antisym", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "antisym", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "b", "c"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.exp_antisym", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "exp_antisym", "type": "function", "doc": "<p>Matrix exponential of antisym(a,b,c).\nNote : (a,b,c) is the axis of rotation.</p>\n", "parameters": ["a", "b", "c"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.advance", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "advance", "type": "function", "doc": "<p>Move from a state to another by applying a control during a unit time</p>\n", "parameters": ["state", "control"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.make_hamiltonian", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "make_hamiltonian", "type": "function", "doc": "<p>Produces the hamiltonian function associated to a sub-Riemannian model, \ndefined by its controls and the advance function</p>\n", "parameters": ["controls", "advance"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.MakeStencil", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "MakeStencil", "type": "function", "doc": "<p></p>\n", "parameters": ["refine_pred"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.PlotStencil", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "PlotStencil", "type": "function", "doc": "<p></p>\n", "parameters": ["stencil"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.ball_and_stencil", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "ball_and_stencil", "type": "function", "doc": "<p></p>\n", "parameters": ["metric", "level", "name"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.MakeRandomTensor", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "MakeRandomTensor", "type": "function", "doc": "<p></p>\n", "parameters": ["dim", "shape", "relax"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.Reconstruct", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "Reconstruct", "type": "function", "doc": "<p></p>\n", "parameters": ["coefs", "offsets"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.offsets_prereduced", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "offsets_prereduced", "type": "function", "doc": "<p>Offsets of the decomposition associated to a prereduced basis. Assumes |det(b1,b2)|=1.</p>\n", "parameters": ["b1", "b2"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.coefs_prereduced", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "coefs_prereduced", "type": "function", "doc": "<p>Coefficients of the decomposition associated to a prereduced basis.</p>\n", "parameters": ["D", "b1", "b2"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.coefs_Selling", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "coefs_Selling", "type": "function", "doc": "<p>Coefficients of Selling's decomposition.</p>\n", "parameters": ["D", "b0", "b1", "b2"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.sigmoid", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "sigmoid", "type": "function", "doc": "<p>-1 -> -1, 1 -> 1, constant outside, smooth inside</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.sigmoid2", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "sigmoid2", "type": "function", "doc": "<p>1/2 -> 0, 1 -> 1, constant outside, smooth inside</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.SmoothDecomposition", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "SmoothDecomposition", "type": "function", "doc": "<p>A smooth interpolation between Selling's decomposition, \nand the one associated to a well chosen prereduced basis.</p>\n", "parameters": ["D"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM", "modulename": "agd.ExportedCode.Notebooks_FMM", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.route_min", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "route_min", "type": "function", "doc": "<p></p>\n", "parameters": ["z", "params"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.metric", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "metric", "type": "function", "doc": "<p></p>\n", "parameters": ["params"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.Spherical", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "Spherical", "type": "function", "doc": "<p>Spherical embedding: \u03b8 is longitude, \u03d5 is latitude from equator toward pole</p>\n", "parameters": ["\u03b8", "\u03c6"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.IntrinsicMetric", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "IntrinsicMetric", "type": "function", "doc": "<p>Riemannian metric for a manifold embedded in Euclidean space</p>\n", "parameters": ["Embedding", "X"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.bump", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "bump", "type": "function", "doc": "<p>Gaussian-like bump (not normalized)</p>\n", "parameters": ["x", "y"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.Currents", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "Currents", "type": "function", "doc": "<p>Some arbitrary vector field (water currents)</p>\n", "parameters": ["\u03b8", "\u03c6"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.ArrivalTime", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "ArrivalTime", "type": "function", "doc": "<p></p>\n", "parameters": ["hfmIn", "params"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.PoincareCost", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "PoincareCost", "type": "function", "doc": "<p>Cost function defining the Poincare half plane model of the hyperbolic plane.</p>\n", "parameters": ["q"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.PoincareDistance", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "PoincareDistance", "type": "function", "doc": "<p>Distance between two points of the half plane model of the hyperbolic plane.</p>\n", "parameters": ["p", "q"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.diff", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "diff", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "y", "\u03b1"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RiemannMetric", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RiemannMetric", "type": "function", "doc": "<p></p>\n", "parameters": ["diag", "diff", "x", "y"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RiemannExact", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RiemannExact", "type": "function", "doc": "<p></p>\n", "parameters": ["diag", "diff", "x", "y"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.v", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "v", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "y", "\u03b3"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RanderMetric", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RanderMetric", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "y", "\u03b3"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RanderSolution", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RanderSolution", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "y", "\u03b3"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.ConformalMap", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "ConformalMap", "type": "function", "doc": "<p>Implements the mapping x -> (1/2) * x^2, where x is seen as a complex variable.</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.ConformalApply", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "ConformalApply", "type": "function", "doc": "<p>Applies a conformal change of coordinates to a norm.\ndecomp : decompose the Jacobian into a scaling and rotation.</p>\n", "parameters": ["norm", "f", "x", "decomp"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.MappedNormValues", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "MappedNormValues", "type": "function", "doc": "<p></p>\n", "parameters": ["norm", "f", "x", "seed"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv", "modulename": "agd.ExportedCode.Notebooks_NonDiv", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D.streamplot_ij", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "streamplot_ij", "type": "function", "doc": "<p></p>\n", "parameters": ["X", "Y", "VX", "VY", "subsampling", "varargs", "kwargs"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D.SchemeCentered", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "SchemeCentered", "type": "function", "doc": "<p>Discretization of a linear non-divergence form second order PDE\ncst + mult u + <omega,grad u>- tr(diff hess(u)) = 0\nSecond order accurate, centered yet monotone finite differences are used for <omega,grad u></p>\n\n<ul>\n<li>bc : boundary conditions. </li>\n<li>ret_hmax : return the largest grid scale for which monotony holds</li>\n</ul>\n", "parameters": ["u", "cst", "mult", "omega", "diff", "bc", "ret_hmax"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D.SchemeUpwind", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "SchemeUpwind", "type": "function", "doc": "<p>Discretization of a linear non-divergence form second order PDE\ncst + mult u + <omega,grad u>- tr(diff hess(u)) = 0\nFirst order accurate, upwind finite differences are used for <omega,grad u></p>\n\n<ul>\n<li>bc : boundary conditions.</li>\n</ul>\n", "parameters": ["u", "cst", "mult", "omega", "diff", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeNonMonotone", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeNonMonotone", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "f", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.MALBR_H", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "MALBR_H", "type": "function", "doc": "<p></p>\n", "parameters": ["d2u"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeMALBR", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeMALBR", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "SB", "f", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.InvalidMALBR", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "InvalidMALBR", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "SB", "f", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeMALBR_OptInner", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeMALBR_OptInner", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "SB", "bc", "oracle"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeMALBR_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeMALBR_Opt", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "SB", "f", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.ConstrainedMaximize", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "ConstrainedMaximize", "type": "function", "doc": "<p></p>\n", "parameters": ["Q", "l", "m"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeUniform", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeUniform", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "SB", "f", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeUniform_OptInner", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeUniform_OptInner", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "SB", "f", "bc", "oracle"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeUniform_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeUniform_Opt", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "SB", "f", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.Hessian_ad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "Hessian_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "x"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.MongeAmpere_ad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "MongeAmpere_ad", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "x"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.Gradient", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "Gradient", "type": "function", "doc": "<p>Approximates grad u(x), using finite differences along the axes of A.</p>\n", "parameters": ["u", "A", "bc", "decomp"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.SchemeCentered", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "SchemeCentered", "type": "function", "doc": "<p>Discretization of - Tr(A(x) hess u(x)) + F(grad u(x)) - rhs,\nwith Dirichlet boundary conditions. The scheme is second order,\nand degenerate elliptic under suitable assumptions.</p>\n", "parameters": ["u", "A", "F", "rhs", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.SchemeCentered_Quad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "SchemeCentered_Quad", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "A", "omega", "D", "rhs", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.SchemeUpwind", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "SchemeUpwind", "type": "function", "doc": "<p>Discretization of -Tr(A(x) hess u(x)) + \\| grad u(x) - omega(x) \\|_D(x)^2 - rhs,\nwith Dirichlet boundary conditions, using upwind finite differences for the first order part.\nThe scheme is degenerate elliptic if A and D are positive definite.</p>\n", "parameters": ["u", "A", "omega", "D", "rhs", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeNonMonotone", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeNonMonotone", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "\u03b1", "\u03b2", "bc", "sqrt_relax"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeSampling", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeSampling", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "diffs", "\u03b2", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.Diff", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "Diff", "type": "function", "doc": "<p></p>\n", "parameters": ["\u03b1", "\u03b8"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeSampling_OptInner", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeSampling_OptInner", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "diffs", "bc", "oracle"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeSampling_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeSampling_Opt", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "diffs", "\u03b2", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.MakeD", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "MakeD", "type": "function", "doc": "<p></p>\n", "parameters": ["\u03b1"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.NextAngleAndSuperbase", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "NextAngleAndSuperbase", "type": "function", "doc": "<p></p>\n", "parameters": ["\u03b8", "sb", "D"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.AnglesAndSuperbases", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "AnglesAndSuperbases", "type": "function", "doc": "<p></p>\n", "parameters": ["D", "maxiter"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.MinimizeTrace", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "MinimizeTrace", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "\u03b1", "bc", "sqrt_relax"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeConsistent", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeConsistent", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "\u03b1", "\u03b2", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.MinimizeTrace_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "MinimizeTrace_Opt", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "\u03b1", "bc", "oracle"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeConsistent_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeConsistent_Opt", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "\u03b1", "\u03b2", "bc"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.Pucci_ad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "Pucci_ad", "type": "function", "doc": "<p>Computes alpha*lambda_max(D^2 u) + lambda_min(D^2 u), \nat the given set of points, by automatic differentiation.</p>\n", "parameters": ["u", "\u03b1", "x"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.EvalScheme", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "EvalScheme", "type": "function", "doc": "<p>Evaluates the (piecewise) quadratic equation defining the numerical scheme.\nInputs :</p>\n\n<ul>\n<li>uc : plays the role of \u03bb</li>\n</ul>\n", "parameters": ["cp", "u", "uc", "params"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.LocalSolve", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "LocalSolve", "type": "function", "doc": "<p>Solve the (piecewise) quadratic equation defining the numerical scheme.\nOutput: solution \u03bb.</p>\n", "parameters": ["cp", "vx", "vy", "wx", "wy", "params"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.JacobiIteration", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "JacobiIteration", "type": "function", "doc": "<p>One Jacobi iteration, returning the pointwise solution \u03bb to the numerical scheme.</p>\n", "parameters": ["u", "Omega", "c", "params"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.OneBump", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "OneBump", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "y"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.ThreeBumps", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "ThreeBumps", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "y"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.Volcano", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "Volcano", "type": "function", "doc": "<p></p>\n", "parameters": ["x", "y"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.GenerateRHS", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "GenerateRHS", "type": "function", "doc": "<p></p>\n", "parameters": ["height", "params"], "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv", "modulename": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv.accumulate", "modulename": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv", "qualname": "accumulate", "type": "function", "doc": "<p></p>\n", "parameters": ["iterable", "func", "initial"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences", "modulename": "agd.FiniteDifferences", "qualname": "", "type": "module", "doc": "<p>This module implements some finite differences operations, as well as related array \nreshaping and broadcasting operations. The main functions are the following, see the \nthe detailed help below.</p>\n\n<p>Elementary finite differences:</p>\n\n<ul>\n<li>DiffUpwind</li>\n<li>DiffCentered</li>\n<li>Diff2</li>\n</ul>\n\n<p>Array broadcasting:</p>\n\n<ul>\n<li>as_field</li>\n<li>common_field</li>\n</ul>\n\n<p>Block based array reshaping:</p>\n\n<ul>\n<li>block_expand</li>\n<li>block_squeeze</li>\n</ul>\n"}, {"fullname": "agd.FiniteDifferences.as_field", "modulename": "agd.FiniteDifferences", "qualname": "as_field", "type": "function", "doc": "<p>Checks if the last dimensions of u match the given shape. \nIf not, u is extended with these additional dimensions.\nconditional : if False, reshaping is always done\ndepth (optional) : the depth of the geometrical tensor field (1: vectors, 2: matrices)</p>\n", "parameters": ["u", "shape", "conditional", "depth"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.common_field", "modulename": "agd.FiniteDifferences", "qualname": "common_field", "type": "function", "doc": "<p>Adds trailing dimensions, and broadcasts the given arrays, for suitable interoperation.</p>\n\n<p>Inputs: </p>\n\n<ul>\n<li>arrays : a list [a_1,...,a_n], or iterable, of numeric arrays such that\na_i.shape = shape_i + shape, or a_i.shape = shape_i, for each 1&lt;=i&lt;=n.</li>\n<li>depths : defined as [len(shape_i) for 1&lt;=i&lt;=n]</li>\n<li>shape (optional) : the trailing shape.</li>\n</ul>\n\n<p>Output:</p>\n\n<ul>\n<li>the arrays, with added trailing and dimensions broadcasting so that\na_i.shape = shape_i + shape for each 1&lt;=i&lt;=n.</li>\n</ul>\n", "parameters": ["arrays", "depths", "shape"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.round_up_ratio", "modulename": "agd.FiniteDifferences", "qualname": "round_up_ratio", "type": "function", "doc": "<p>Returns the least multiple of den after num.\nnum and den must be integers, with den>0.</p>\n", "parameters": ["num", "den"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.block_expand", "modulename": "agd.FiniteDifferences", "qualname": "block_expand", "type": "function", "doc": "<p>Reshape an array so as to factor shape_i (the inner shape),\nand move these axes last.\nInputs : </p>\n\n<ul>\n<li>**kwargs : passed to np.pad\nOutput : </li>\n<li>padded and reshaped array</li>\n</ul>\n", "parameters": ["arr", "shape_i", "renumber_ad", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.block_squeeze", "modulename": "agd.FiniteDifferences", "qualname": "block_squeeze", "type": "function", "doc": "<p>Inverse operation to block_expand.</p>\n", "parameters": ["arr", "shape", "renumber_ad"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.BoundedSlices", "modulename": "agd.FiniteDifferences", "qualname": "BoundedSlices", "type": "function", "doc": "<p>Returns the input slices with None replaced with the upper bound\nfrom the given shape</p>\n", "parameters": ["slices", "shape"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.OffsetToIndex", "modulename": "agd.FiniteDifferences", "qualname": "OffsetToIndex", "type": "function", "doc": "<p>Returns the index corresponding to position + offset, \nand a boolean for wether it falls inside the domain.\nSet padding=None for periodic boundary conditions</p>\n", "parameters": ["shape", "offset", "mode", "uniform", "where"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.TakeAtOffset", "modulename": "agd.FiniteDifferences", "qualname": "TakeAtOffset", "type": "function", "doc": "<p></p>\n", "parameters": ["u", "offset", "padding", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.AlignedSum", "modulename": "agd.FiniteDifferences", "qualname": "AlignedSum", "type": "function", "doc": "<p>Returns sum along the direction offset, with specified multiples and weights</p>\n", "parameters": ["u", "offset", "multiples", "weights", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.Diff2", "modulename": "agd.FiniteDifferences", "qualname": "Diff2", "type": "function", "doc": "<p>Approximates <offset, (d^2 u) offset> with second order accuracy.\nSecond order finite difference in the specidied direction.</p>\n", "parameters": ["u", "offset", "gridScale", "order", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffUpwind", "modulename": "agd.FiniteDifferences", "qualname": "DiffUpwind", "type": "function", "doc": "<p>Approximates <grad u, offset> with specified accuracy order.\nUpwind first order finite difference in the specified direction.\nNote: only order=1 yields degenerate elliptic schemes.</p>\n", "parameters": ["u", "offset", "gridScale", "order", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffCentered", "modulename": "agd.FiniteDifferences", "qualname": "DiffCentered", "type": "function", "doc": "<p>Approximates <d u, offset> with second order accuracy.\nCentered first order finite difference in the specified direction.</p>\n", "parameters": ["u", "offset", "gridScale", "order", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffCross", "modulename": "agd.FiniteDifferences", "qualname": "DiffCross", "type": "function", "doc": "<p>Approximates <offsets0, (d^2 u) offset1> with second order accuracy.\nCentered finite differences scheme, but lacking the degenerate ellipticity property.</p>\n", "parameters": ["u", "offset0", "offset1", "gridScale", "order", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.AxesOffsets", "modulename": "agd.FiniteDifferences", "qualname": "AxesOffsets", "type": "function", "doc": "<p>Returns the offsets corresponding to the axes.\n        Inputs : </p>\n\n<ul>\n<li>offsets (optional). Defaults to np.eye(dimension)</li>\n<li>dimension (optional). Defaults to u.ndim</li>\n</ul>\n", "parameters": ["u", "offsets", "dimension"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffHessian", "modulename": "agd.FiniteDifferences", "qualname": "DiffHessian", "type": "function", "doc": "<p>Approximates the matrix (<offsets[i], (d^2 u) offsets[j]&gt; )_{ij}, using AxesOffsets as offsets.\nCentered and cross finite differences are used, thus lacking the degenerate ellipticity property.</p>\n", "parameters": ["u", "offsets", "dimension", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffGradient", "modulename": "agd.FiniteDifferences", "qualname": "DiffGradient", "type": "function", "doc": "<p>Approximates the vector (<d u, offsets[i]&gt;)_i, using AxesOffsets as offsets\nCentered finite differences are used, thus lacking the degerate ellipticity property.</p>\n", "parameters": ["u", "offsets", "dimension", "kwargs"], "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.UniformGridInterpolator1D", "modulename": "agd.FiniteDifferences", "qualname": "UniformGridInterpolator1D", "type": "function", "doc": "<p>Interpolation on a uniform grid. mode is in ('clip','wrap', ('fill',fill_value) )</p>\n", "parameters": ["bounds", "values", "mode", "axis"], "funcdef": "def"}, {"fullname": "agd.Interpolation", "modulename": "agd.Interpolation", "qualname": "", "type": "module", "doc": "<p>This file implements some spline interpolation methods, on uniform grids,\nin a manner compatible with automatic differentiation.</p>\n\n<p>If none of the involved arrays use automatic differentiation, and if the options are \ncompatible, then a bypass through ndimage may be used.</p>\n"}, {"fullname": "agd.Interpolation.origin_scale_shape", "modulename": "agd.Interpolation", "qualname": "origin_scale_shape", "type": "function", "doc": "<p>This function is indended for extracting the origin, scale, and shape,\nof a uniform coordinate system provided as a meshgrid.</p>\n", "parameters": ["grid"], "funcdef": "def"}, {"fullname": "agd.Interpolation.map_coordinates", "modulename": "agd.Interpolation", "qualname": "map_coordinates", "type": "function", "doc": "<p>Thin wrapper over the ndimage.map_coordinates function, which adds the possibility of \nrescaling the coordinates using a reference grid, and interpolating tensors.\nWill dispatch to cupyx.scipy.ndimage.map_coordinates if needed.</p>\n\n<p>Additional inputs : </p>\n\n<ul>\n<li>grid (optional) : reference coordinate system, which must be uniform</li>\n<li>origin,scale (optional) : obtained from origin_scale_shape(grid)</li>\n<li>depth : depth of interpolated objects 0->scalar, 1->vector, 2->matrix</li>\n<li>order (optional) : set default 1 for better cupy/numpy reproducibility</li>\n</ul>\n", "parameters": ["input", "coordinates", "args", "grid", "origin", "scale", "depth", "order", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Interpolation.UniformGridInterpolation", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation", "type": "class", "doc": "<p>Interpolates values on a uniform grid, in arbitrary dimension, using splines of \na given order.</p>\n"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.__init__", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.__init__", "type": "function", "doc": "<ul>\n<li>grid (ndarray) : must be a uniform grid. E.g. np.meshgrid(aX,aY,indexing='ij')\nwhere aX,aY have uniform spacing. Alternatively, provide only the axes.</li>\n<li>values (ndarray) : interpolated values.</li>\n<li>order (int, tuple of ints) : spline interpolation order (&lt;=3), along each axis.</li>\n<li>periodic (bool, tuple of bool) : wether periodic interpolation, along each axis.</li>\n</ul>\n", "parameters": ["self", "grid", "values", "order", "periodic", "check_grid"], "funcdef": "def"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.vdim", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.vdim", "type": "variable", "doc": "<p>Vector dimension of the interpolation points.</p>\n"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.oshape", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.oshape", "type": "variable", "doc": "<p>Number of dimension of the interpolated objects.</p>\n"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.set_values", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.set_values", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "values"], "funcdef": "def"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.make_coefs", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.make_coefs", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "values", "overwrite_values"], "funcdef": "def"}, {"fullname": "agd.LinearPDE", "modulename": "agd.LinearPDE", "qualname": "", "type": "module", "doc": "<p>This module is DEPRECATED, but kept for compatibility.</p>\n"}, {"fullname": "agd.LinearPDE.OperatorMatrix", "modulename": "agd.LinearPDE", "qualname": "OperatorMatrix", "type": "function", "doc": "<p>Constructs a linear operator sparse matrix, given as input </p>\n\n<ul>\n<li>an array <code>diff</code> of symmetric positive definite matrices, \n    with shape $(d,d,n_1,...,n_d)$ where $d$ is the domain dimension.</li>\n<li>an array <code>omega</code> of vectors (optionnal), with shape $(d,n_1,...,n_d)$.</li>\n<li>an array of scalars (optionnal), with shape $(n_1,...,n_d)$.</li>\n</ul>\n\n<p>additional parameters</p>\n\n<ul>\n<li>a grid scale </li>\n<li>boundary conditions, possibly axis by axis \n    ('Periodic', 'Reflected', 'Neumann', 'Dirichlet') </li>\n<li>divergence form or not</li>\n</ul>\n\n<p>The discretized operator is\n$$\n {-} \\mathrm{div}(D \\nabla u) + &lt; \\omega, \\nabla u> + mult*u,\n$$\ndenoting $D:=$<code>diff</code> and $\\omega:=$<code>omega</code>.</p>\n\n<p>Replace the first term with $\\mathrm{Tr}(D \\nabla^2 u)$ in the \nnon-divergence form case.</p>\n\n<p>Returns : a list of triplets, for building a coo matrix</p>\n", "parameters": ["diff", "omega", "mult", "gridScale", "boundaryConditions", "divergenceForm", "intrinsicDrift"], "funcdef": "def"}, {"fullname": "agd.LinearParallel", "modulename": "agd.LinearParallel", "qualname": "", "type": "module", "doc": "<p>This module implements some basic linear algebra routines, with the following characteristics.</p>\n\n<ul>\n<li>The geometry comes first, a.k.a vector has shape (vdim, n1,...,nk) where vdim is the \nambient vector space dimension, and n1,...,nk are arbitrary. \nNote that <em>numpy uses the opposite convention</em>, putting vdim in last position.</li>\n<li>The routines are compatible with forward automatic differentiation, see module\nAutomaticDifferentiation.</li>\n</ul>\n"}, {"fullname": "agd.LinearParallel.identity", "modulename": "agd.LinearParallel", "qualname": "identity", "type": "function", "doc": "<p></p>\n", "parameters": ["shape"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.rotation", "modulename": "agd.LinearParallel", "qualname": "rotation", "type": "function", "doc": "<p>Dimension 2 : by a given angle.\nDimension 3 : by a given angle, along a given axis.\nThree dimensional rotation matrix, with given axis and angle.\nAdapted from https://stackoverflow.com/a/6802723</p>\n", "parameters": ["theta", "axis"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_VV", "modulename": "agd.LinearParallel", "qualname": "dot_VV", "type": "function", "doc": "<p>Dot product <v,w> of two vectors.\nInputs : </p>\n\n<ul>\n<li>v,w : arrays of shape (vdim, n1,...,nk), \nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["v", "w"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_AV", "modulename": "agd.LinearParallel", "qualname": "dot_AV", "type": "function", "doc": "<p>Dot product a.v of a matrix and vector.\nInputs : </p>\n\n<ul>\n<li>a : array of shape (wdim,vdim, n1,...,nk)</li>\n<li>v : array of shape (vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["a", "v"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_VA", "modulename": "agd.LinearParallel", "qualname": "dot_VA", "type": "function", "doc": "<p>Dot product v^T.a of a vector and matrix.\nInputs : </p>\n\n<ul>\n<li>v : array of shape (vdim, n1,...,nk)</li>\n<li>a : array of shape (vdim,wdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["v", "a"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_AA", "modulename": "agd.LinearParallel", "qualname": "dot_AA", "type": "function", "doc": "<p>Dot product a.b of two matrices.\nInputs : </p>\n\n<ul>\n<li>a: array of shape (vdim,wdim, n1,...,nk),</li>\n<li>a: array of shape (wdim,xdim, n1,...,nk),</li>\n</ul>\n", "parameters": ["a", "b"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_VAV", "modulename": "agd.LinearParallel", "qualname": "dot_VAV", "type": "function", "doc": "<p>Dot product <v,a.w> of two vectors and a matrix (usually symmetric).\nInputs (typical): </p>\n\n<ul>\n<li>v: array of shape (vdim, n1,...,nk),  </li>\n<li>a: array of shape (vdim,vdim, n1,...,nk),</li>\n<li>w: array of shape (vdim, n1,...,nk),</li>\n</ul>\n", "parameters": ["v", "a", "w"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.mult", "modulename": "agd.LinearParallel", "qualname": "mult", "type": "function", "doc": "<p>Multiplication by scalar, of a vector or matrix</p>\n", "parameters": ["k", "x"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.perp", "modulename": "agd.LinearParallel", "qualname": "perp", "type": "function", "doc": "<p>Rotates a vector by pi/2, producing [v[1],v[0]]\nInputs: </p>\n\n<ul>\n<li>v: array of shape (2, n1,...,nk)</li>\n</ul>\n", "parameters": ["v"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.cross", "modulename": "agd.LinearParallel", "qualname": "cross", "type": "function", "doc": "<p>Cross product v x w of two vectors.\nInputs: </p>\n\n<ul>\n<li>v,w: arrays of shape (3, n1,...,nk)</li>\n</ul>\n", "parameters": ["v", "w"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.outer", "modulename": "agd.LinearParallel", "qualname": "outer", "type": "function", "doc": "<p>Outer product v w^T of two vectors.\nInputs : </p>\n\n<ul>\n<li>v,w: arrays of shape (vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["v", "w"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.outer_self", "modulename": "agd.LinearParallel", "qualname": "outer_self", "type": "function", "doc": "<p>Outer product v v^T of a vector with itself.\nInputs : </p>\n\n<ul>\n<li>v: array of shape (vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["v"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.transpose", "modulename": "agd.LinearParallel", "qualname": "transpose", "type": "function", "doc": "<p>Transpose a^T of a matrix.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,wdim, n1,...,nk),</li>\n</ul>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.trace", "modulename": "agd.LinearParallel", "qualname": "trace", "type": "function", "doc": "<p>Trace tr(a) of a square matrix, a.k.a sum of the diagonal elements.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.det", "modulename": "agd.LinearParallel", "qualname": "det", "type": "function", "doc": "<p>Determinant of a square matrix.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.inverse", "modulename": "agd.LinearParallel", "qualname": "inverse", "type": "function", "doc": "<p>Inverse of a square matrix.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["a"], "funcdef": "def"}, {"fullname": "agd.LinearParallel.solve_AV", "modulename": "agd.LinearParallel", "qualname": "solve_AV", "type": "function", "doc": "<p>Solution to a linear system (preferably low dimensional).\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),</li>\n<li>v: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "parameters": ["a", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics", "modulename": "agd.Metrics", "qualname": "", "type": "module", "doc": "<p>The Metrics package defines a variety of norms on R^d, defined by appropriate parameters,\npossibly non-symmetric. The data of a such a norm, at each point of a domain, is referred \nto as a metric, for instance a Riemannian metric, and defines a path-length distance \nover the domain.</p>\n\n<p>Metrics are the fundamental input to (generalized) eikonal equations, which can be solved\nusing the provided Eikonal module.</p>\n\n<p>Main norm/metric classes:</p>\n\n<ul>\n<li>Isotropic : a multiple of the Euclidean norm on $R^d$.</li>\n<li>Diagonal : axis-dependent multiple of the Euclidean norm.</li>\n<li>Riemann : anisotropic norm on $R^d$ defined by a symmetric positice definite matrix of \nshape $(d,d)$. Used to define a Riemannian metric.</li>\n<li>Rander : non-symmetric anisotropic norm, defined as the sum of a Riemann norm and \nof a drift term.</li>\n<li>AsymQuad : non-symmetric anisotropic norm, defined by gluing two Riemann norms along \na hyperplane.</li>\n</ul>\n\n<p>Additional norm/metric classes are defined in the Seismic subpackage.</p>\n"}, {"fullname": "agd.Metrics.Seismic", "modulename": "agd.Metrics.Seismic", "qualname": "", "type": "module", "doc": "<p>The seismic package defines norms/metrics that characterize the first arrival time of\nelastic waves in anisotropic materials. It also provides helper functions for solving \nthe elastic wave equation itself.</p>\n\n<p>Main metric/norm classes:</p>\n\n<ul>\n<li>Hooke : norm defined by a Hooke tensor, corresponding to the fastest velocity.</li>\n<li>TTI : tilted transversally isotropic norm.</li>\n</ul>\n"}, {"fullname": "agd.Metrics.Seismic.hooke", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke", "type": "class", "doc": "<p>The <em>dual</em> norm defined by a Hooke tensor takes the form \n$$\nF^*(x) = \\max_{|y|\\leq 1} \\sqrt{\\sum_{ijkl} c_{ijkl} x_i y_j x_k y_l}\n$$\nwhere c is the Hooke tensor, and y ranges over the unit ball.\nThe primal norm is obtained implicitly, by solving an optimization problem.</p>\n\n<p>These norms characterize the arrival time of pressure waves in elasticity. \nThey are often encountered in seismic traveltime tomography.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>hooke : an array of shape (hdim,hdim,n1,...,nk) where hdim = vdim*(vdim+1)/2\nand vdim is the ambient space dimension. The array must be symmetric, and encodes the\nhooke tensor c in Voigt notation.</li>\n<li><em>args,</em>*kwargs (optional) : passed to ImplicitBase</li>\n</ul>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.__init__", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "hooke", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.is_definite", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.is_definite", "type": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.vdim", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.shape", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.model_HFM", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.flatten", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.expand", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.with_cost", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.with_cost", "type": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "parameters": ["self", "cost"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.extract_xz", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.extract_xz", "type": "function", "doc": "<p>Extract a two dimensional Hooke tensor from a three dimensional one, \ncorresponding to a slice through the X and Z axes.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_VTI_2", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_VTI_2", "type": "function", "doc": "<p>X,Z slice of a Vertical Transverse Isotropic medium\nbased on Thomsen parameters</p>\n", "parameters": ["cls", "Vp", "Vs", "eps", "delta"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_Ellipse", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_Ellipse", "type": "function", "doc": "<p>Rank deficient Hooke tensor,\nequivalent, for pressure waves, to the Riemannian metric defined by $m ^ {-2}$.\nShear waves are infinitely slow.</p>\n", "parameters": ["cls", "m"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_cast", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_depth4", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_depth4", "type": "function", "doc": "<p>Produces the full Hooke tensor, of shape\n(vdim,vdim,vdim,vdim, n1,...,nk)\nwhere vdim is the ambient space dimension.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.rotate", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.rotate", "type": "function", "doc": "<p>Rotation of the norm, by a given rotation matrix.\nThe new unit ball is the direct image of the previous one.</p>\n", "parameters": ["self", "r"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_Mandel", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_Mandel", "type": "function", "doc": "<p>Introduces the $\\sqrt 2$ and $2$ factors involved in Mandel's notation</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_Mandel", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_Mandel", "type": "function", "doc": "<p>Removes the $\\sqrt 2$ and $2$ factors involved in Mandel's notation</p>\n", "parameters": ["cls", "mandel", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_orthorombic", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_orthorombic", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "c11", "c12", "c13", "c22", "c23", "c33", "c44", "c55", "c66"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_orthorombic2", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_orthorombic2", "type": "function", "doc": "<p>Orthorombic medium with a different ordering of the first block coefficients</p>\n", "parameters": ["cls", "c11", "c21", "c22", "c31", "c32", "c33", "c44", "c55", "c66"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_tetragonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_tetragonal", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "c11", "c12", "c13", "c33", "c44", "c66"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_hexagonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_hexagonal", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "c11", "c12", "c13", "c33", "c44"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_Thomsen", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_Thomsen", "type": "function", "doc": "<p>Hooke tensor (m/s)^2 and density (g/cm^3)</p>\n", "parameters": ["cls", "tem"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_orthorombic", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_orthorombic", "type": "function", "doc": "<p>Inverse function of from_orthorombic. No reconstruction check.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_orthorombic2", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_orthorombic2", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_tetragonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_tetragonal", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_hexagonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_hexagonal", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.is_TTI", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.is_TTI", "type": "function", "doc": "<p>Determine if the metric is in a TTI form.</p>\n", "parameters": ["self", "tol"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.dot_A", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.dot_A", "type": "function", "doc": "<p>Dot product associated with a Hooke tensor, which turns a strain tensor epsilon\ninto a stress tensor sigma.</p>\n\n<p>Input:</p>\n\n<ul>\n<li>m : the strain tensor.</li>\n</ul>\n", "parameters": ["self", "m", "sym"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.dot_AA", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.dot_AA", "type": "function", "doc": "<p>Inner product associated with a Hooke tensor, on the space of symmetric matrices.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>m1 : first symmetric matrix</li>\n<li>m2 : second symmetric matrix. Defaults to m1.</li>\n</ul>\n", "parameters": ["self", "m1", "m2", "sym"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.Selling", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.Selling", "type": "function", "doc": "<p>Returns a decomposition of the hooke tensor in the mathematical form\n$$\nhooke = \\sum_i \\rho_i m_i  m_i^\\top,\n$$\nwhere $\\rho_i$ is a non-negative coefficient, $m_i$ is symmetric nonzero and has \ninteger entries, and $\\sum_i \\rho_i$ is maximal.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.apply_transform", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.apply_transform", "type": "function", "doc": "<p>Applies the transformation, if any stored, to the hooke tensor. </p>\n\n<p>CAUTION : this feature is required for some applications to elasticity, \nbut is incompatible with the eikonal equation solver.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_Lame", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_Lame", "type": "function", "doc": "<p>Constructs a Hooke tensor from the Lame coefficients, in dimension 2 or 3.</p>\n", "parameters": ["cls", "Lambda", "Mu", "vdim"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.contract", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.contract", "type": "function", "doc": "<p>Returns the contracted tensor $\\sum_{j,l}c_{ijkl} w_j w_l$.</p>\n", "parameters": ["self", "w"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.waves", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.waves", "type": "function", "doc": "<p>Returns the pulsation and direction of the waves with the given wave vector.</p>\n", "parameters": ["self", "w", "rho"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.mica", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.mica", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.stishovite", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.stishovite", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.olivine", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.olivine", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase", "type": "class", "doc": "<p>Base class for a metric defined implicitly, \nin terms of a level set function for the unit ball\nof the dual metric, and of a linear transformation.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>niter_sqp (int, optional): number of iterations for Sequential Quadratic Programming</li>\n<li>relax_sqp (tuple,optional): relaxation parameter for the first iterations of SQP</li>\n<li>qconv_sqp (real, optional): such that hessian+quasi_sqp<em>grad^T grad &gt; 0. Used when \nthe constraint is a quasi-convex function, but exp(qconv_sqp</em>f) is strongly convex</li>\n</ul>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.__init__", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "inverse_transformation", "niter_sqp", "relax_sqp", "qconv_sqp"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.norm", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.gradient", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.gradient", "type": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.inv_transform", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.inv_transform", "type": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.is_topographic", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.is_topographic", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.flatten_transform", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.flatten_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "topographic"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.sequential_quadratic", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "sequential_quadratic", "type": "function", "doc": "<p>Maximizes <x,v> subject to the constraint f(x,*params)&lt;=0, \nusing sequential quadratic programming.\nx : initial guess.\nrelax : relaxation parameters to be used in a preliminary path following phase.\nparams : to be passed to evaluated function. Special treatment if ad types.</p>\n", "parameters": ["v", "f", "niter", "x", "params", "relax", "qconv"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced", "type": "class", "doc": "<p>A family of reduced models appearing in seismic tomography, \nbased on assuming that some of the coefficients of the Hooke tensor vanish.</p>\n\n<p>The dual ball is defined by an equation of the form \nl(X^2,Y^2,Z^2) + q(X^2,Y^2,Z^2) + c X^2 Y^2 Z^2 = 1\nwhere l is linear, q is quadratic, and c is a cubic coefficient.\nX,Y,Z are the coefficients of the input vector, perhaps subject to a linear transformation.</p>\n"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.__init__", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "linear", "quadratic", "cubic", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.vdim", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.shape", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.cost_bound", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.cost_bound", "type": "function", "doc": "<p>Upper bound on norm(u), for any unit vector u.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.from_cast", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.to_TTI3", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.to_TTI3", "type": "function", "doc": "<p>Produces a three dimensional norm of TTI type (tilted transversally isotropic), \nfrom two dimensional one.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.is_TTI", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.is_TTI", "type": "function", "doc": "<p>Wether the norm is of tilted transversally isotropic type</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.model_HFM", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.flatten", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self", "transposed_transformation"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.expand", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.from_Hooke", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.from_Hooke", "type": "function", "doc": "<p>Generate reduced algebraic form from full Hooke tensor.\n!! Warning !!  Hooke to Reduced conversion requires that some \ncoefficients of the Hooke tensor vanish, which is currently not checked,\nand may induce approximations.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.from_Thomsen", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.from_Thomsen", "type": "function", "doc": "<p>Constructs a VTI (vertical transversely anisotropic) metric from Thomsen \nparameters. See  \"Weak elastic anisotropy\" (Thomsen, 1986).</p>\n\n<ul>\n<li>Vp (m/s)</li>\n<li>Vs (m/s)</li>\n<li>eps (dimensionless)</li>\n<li>delta (dimensionless)</li>\n<li>rho (g/cm^3)</li>\n</ul>\n", "parameters": ["cls", "Vp", "Vs", "eps", "delta", "rho"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.reduced_Deprecated.Reduced.ThomsenExample", "modulename": "agd.Metrics.Seismic.reduced_Deprecated", "qualname": "Reduced.ThomsenExample", "type": "function", "doc": "<p>List of VTI examples taken from article \"Weak elastic anisotropy\" (Thomsen, 1986), \nwith Thomsen parameters [Vp,Vs,epsilon,delta].</p>\n", "parameters": ["cls", "i"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "", "type": "module", "doc": "<p>We reproduce in this file list of VTI examples taken from \"Weak elastic anisotropy\" (Thomsen, 1986), \nUnits are : </p>\n\n<ul>\n<li>Vp,Vs : m/s</li>\n<li>'\u03f5','\u03b7','\u03b4','\u03b3' : dimensionless. (Originally, \u03b7 is listed as \u03b4^star.)</li>\n<li>\u03c1 : g/cm^3</li>\n</ul>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial", "type": "class", "doc": "<p>ThomsenElasticMaterial(Vp, Vs, \u03f5, \u03b7, \u03b4, \u03b3, \u03c1)</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.__init__", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.__init__", "type": "function", "doc": "<p>Create new instance of ThomsenElasticMaterial(Vp, Vs, \u03f5, \u03b7, \u03b4, \u03b3, \u03c1)</p>\n", "parameters": ["_cls", "Vp", "Vs", "\u03b5", "\u03b7", "\u03b4", "\u03b3", "\u03c1"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.Vp", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.Vp", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.Vs", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.Vs", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.\u03f5", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.\u03f5", "type": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.\u03b7", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.\u03b7", "type": "variable", "doc": "<p>Alias for field number 3</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.\u03b4", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.\u03b4", "type": "variable", "doc": "<p>Alias for field number 4</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.\u03b3", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.\u03b3", "type": "variable", "doc": "<p>Alias for field number 5</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.\u03c1", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.\u03c1", "type": "variable", "doc": "<p>Alias for field number 6</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM", "type": "class", "doc": "<p>ThomsenElasticMaterial(Vp, Vs, \u03f5, \u03b7, \u03b4, \u03b3, \u03c1)</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.__init__", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.__init__", "type": "function", "doc": "<p>Create new instance of ThomsenElasticMaterial(Vp, Vs, \u03f5, \u03b7, \u03b4, \u03b3, \u03c1)</p>\n", "parameters": ["_cls", "Vp", "Vs", "\u03b5", "\u03b7", "\u03b4", "\u03b3", "\u03c1"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.Vp", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.Vp", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.Vs", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.Vs", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.\u03f5", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.\u03f5", "type": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.\u03b7", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.\u03b7", "type": "variable", "doc": "<p>Alias for field number 3</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.\u03b4", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.\u03b4", "type": "variable", "doc": "<p>Alias for field number 4</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.\u03b3", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.\u03b3", "type": "variable", "doc": "<p>Alias for field number 5</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM.\u03c1", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM.\u03c1", "type": "variable", "doc": "<p>Alias for field number 6</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenUnits", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenUnits", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial", "type": "class", "doc": "<p>HexagonalMaterial(c11, c12, c13, c33, c44)</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.__init__", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.__init__", "type": "function", "doc": "<p>Create new instance of HexagonalMaterial(c11, c12, c13, c33, c44)</p>\n", "parameters": ["_cls", "c11", "c12", "c13", "c33", "c44"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c11", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c11", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c12", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c12", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c13", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c13", "type": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c33", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c33", "type": "variable", "doc": "<p>Alias for field number 3</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c44", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c44", "type": "variable", "doc": "<p>Alias for field number 4</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.get_\u03b4", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "get_\u03b4", "type": "function", "doc": "<p>Reconstructs Thomsen parameter \u03b4, based on the other parameters, \nand the formula in the Thomsen paper.\n(Note : some of the published ThomsenData appears to be inconsistent in this regard.)</p>\n", "parameters": ["Vp", "Vs", "\u03b5", "\u03b7"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalFromTEM", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalFromTEM", "type": "function", "doc": "<p>Returns the coefficients of the reduced Hooke tensor, with hexagonal symmetry, and the density.\nUnits. Reduced hooke tensor : (m/s)^2, density : g/cm^3</p>\n", "parameters": ["tem"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEMFromHexagonal", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEMFromHexagonal", "type": "function", "doc": "<p>Produces the Thomsen parameters, from the coefficients 'hex' of \na Hooke tensor with hexagonal symmetry, and the density '\u03c1'.</p>\n", "parameters": ["hex", "\u03c1"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti", "modulename": "agd.Metrics.Seismic.tti", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI", "type": "class", "doc": "<p>A family of reduced models, known as Tilted Transversally Anisotropic,\nand arising in seismic tomography.</p>\n\n<p>The <em>dual</em> unit ball is defined by an equation of the form\n$$\nl(X^2+Y^2,Z^2) + q(X^2+Y^2,Z^2) = 1,\n$$\nwhere $l$ is linear and $q$ is quadratic, where $X,Y,Z$ are the coefficients \nof the input vector, usually altered by a linear transformation.\nIn two dimensions, ignore the $Y^2$ term.</p>\n\n<p>The primal norm is obtained implicitly, by solving an optimization problem.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>linear : an array of shape (2,n1,...,nk) encoding the linear part l</li>\n<li>quadratic : an array of shape (2,2,n1,...,nk) encoding the quadratic part q</li>\n<li>vdim (optional) : the ambient space dimension</li>\n<li><em>args,</em>*kwargs (optional) : passed to implicit_base</li>\n</ul>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.__init__", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "linear", "quadratic", "vdim", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.vdim", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.shape", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.cost_bound", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.cost_bound", "type": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.Riemann_approx", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.Riemann_approx", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.from_cast", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.model_HFM", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.extract_xz", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.extract_xz", "type": "function", "doc": "<p>Extract a two dimensional Hooke tensor from a three dimensional one, \ncorresponding to a slice through the X and Z axes.\nAxes transformation information (rotation) is discarded.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.flatten", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self", "transposed_transformation"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.expand", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.from_hexagonal", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.from_hexagonal", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "c11", "_", "c13", "c33", "c44", "vdim"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.from_Thomsen", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.from_Thomsen", "type": "function", "doc": "<p>Produces a norm from the given Thomsem elasticity parameters.</p>\n", "parameters": ["cls", "tem", "vdim"], "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.mica", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.mica", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.stishovite2", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.stishovite2", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.asym_quad", "modulename": "agd.Metrics.asym_quad", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad", "type": "class", "doc": "<p>An asymmetric quadratic norm takes the form \n$\nF(x) = \\sqrt{&lt; x, m x &gt; + max(0,&lt; w, x &gt;)^2},\n$\nwhere $m$ is a given symmetric positive definite tensor, \nand w is a given vector.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape (vdim,vdim,n1,..,nk) where vdim is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all 0 &lt;= i &lt; j &lt; vdim.</li>\n<li>w : an array of shape (vdim,n1,...,nk)</li>\n</ul>\n"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.__init__", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "m", "w"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.norm", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.dual", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.dual", "type": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.vdim", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.shape", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.is_definite", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.is_definite", "type": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.anisotropy", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.anisotropy", "type": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.cost_bound", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.cost_bound", "type": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.inv_transform", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.inv_transform", "type": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.with_costs", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.with_costs", "type": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "parameters": ["self", "costs"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.flatten", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self", "solve_w"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.expand", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.model_HFM", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.needle", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.needle", "type": "function", "doc": "<p>Defines a needle like metric</p>\n\n<ul>\n<li>u : reference direction. Denote U = u/|u|, and V the orthogonal unit vector.</li>\n<li>cost_forward =  norm(U)</li>\n<li>cost_orthogonal = norm(V) = norm(-V)</li>\n<li>cost_reverse = norm(-U). (Defaults to cost_orthogonal)</li>\n</ul>\n", "parameters": ["cls", "u", "cost_forward", "cost_orthogonal", "cost_reverse"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.from_cast", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander", "modulename": "agd.Metrics.asym_rander", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.asym_rander.AsymRander", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander", "type": "class", "doc": "<p>Asymmetric Rander norms take the form\n$$\nF(x) = \\sqrt{&lt; x,m x> + max(0,&lt; u,x>)^2 + max(0,&lt; v,x>)^2} + &lt; w,x>\n$$\nwhere m is a given symmetric positive definite tensor, and \n$u,v,w$ are given vectors. The vector $w$ must be small enough, so that $F(x)&gt;0$ \nfor all $x\\neq 0$.</p>\n\n<p>Asymmetric Rander norms generalize both Rander norms and Asymmetric quadratic norms.\nThey were proposed by Da Chen in the context of image processing applications.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape (vdim,vdim,n1,..,nk) where vdim is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all 0&lt;=i<j<vdim.</li>\n<li>u,v,w : an array of shape (vdim,n1,...,nk)</li>\n</ul>\n"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.__init__", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "m", "u", "v", "w"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.norm", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.vdim", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.shape", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.flatten", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.model_HFM", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.from_cast", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.base", "modulename": "agd.Metrics.base", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.base.Base", "modulename": "agd.Metrics.base", "qualname": "Base", "type": "class", "doc": "<p>Base class for a metric, in other words a family of norms.</p>\n"}, {"fullname": "agd.Metrics.base.Base.__init__", "modulename": "agd.Metrics.base", "qualname": "Base.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.norm", "modulename": "agd.Metrics.base", "qualname": "Base.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.gradient", "modulename": "agd.Metrics.base", "qualname": "Base.gradient", "type": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.dual", "modulename": "agd.Metrics.base", "qualname": "Base.dual", "type": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.vdim", "modulename": "agd.Metrics.base", "qualname": "Base.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.base.Base.shape", "modulename": "agd.Metrics.base", "qualname": "Base.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.base.Base.disassociate", "modulename": "agd.Metrics.base", "qualname": "Base.disassociate", "type": "function", "doc": "<p>Hide the automatic differentiation (AD) information of the member fields.\nSee AutomaticDifferentiation.disassociate</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.is_definite", "modulename": "agd.Metrics.base", "qualname": "Base.is_definite", "type": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.anisotropy", "modulename": "agd.Metrics.base", "qualname": "Base.anisotropy", "type": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.anisotropy_bound", "modulename": "agd.Metrics.base", "qualname": "Base.anisotropy_bound", "type": "function", "doc": "<p>An upper bound on the <code>anisotropy</code> of the norm.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.cost_bound", "modulename": "agd.Metrics.base", "qualname": "Base.cost_bound", "type": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.cos_asym", "modulename": "agd.Metrics.base", "qualname": "Base.cos_asym", "type": "function", "doc": "<p>Generalized asymmetric cosine defined by the norm $N$, of the angle between two vectors $u,v$. \nDefined as \n$\\cos^a_N(u,v) := &lt; \\nabla N(u), v> / N(v)$.</p>\n", "parameters": ["self", "u", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.cos", "modulename": "agd.Metrics.base", "qualname": "Base.cos", "type": "function", "doc": "<p>Generalized cosine defined by the norm $N$. Expression\n$\\cos_N(u,v) := \\min( \\cos^a_N (u,v), \\cos^a_N(v,u))$,\nwhere $\\cos^a_N=$<code>cos_asym</code>.</p>\n", "parameters": ["self", "u", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.angle", "modulename": "agd.Metrics.base", "qualname": "Base.angle", "type": "function", "doc": "<p>Generalized unoriented angle defined by the norm,\ndefined as $\\measuredangle_N(u,v) := \\arccos(cos_N(u,v))$.\nSee <code>cos</code> member functions.</p>\n", "parameters": ["self", "u", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.inv_transform", "modulename": "agd.Metrics.base", "qualname": "Base.inv_transform", "type": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.transform", "modulename": "agd.Metrics.base", "qualname": "Base.transform", "type": "function", "doc": "<p>Affine transformation of the norm.\nThe new unit ball is the direct image of the previous one.</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.rotate", "modulename": "agd.Metrics.base", "qualname": "Base.rotate", "type": "function", "doc": "<p>Rotation of the norm, by a given rotation matrix.\nThe new unit ball is the direct image of the previous one.</p>\n", "parameters": ["self", "r"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.rotate_by", "modulename": "agd.Metrics.base", "qualname": "Base.rotate_by", "type": "function", "doc": "<p>Rotation of the norm, based on rotation parameters : angle (and axis in 3D).</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_costs", "modulename": "agd.Metrics.base", "qualname": "Base.with_costs", "type": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "parameters": ["self", "costs"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_speeds", "modulename": "agd.Metrics.base", "qualname": "Base.with_speeds", "type": "function", "doc": "<p>Produces a norm $N'$ obeying \n$$\nN'(x) = N(x/speeds)\n$$ \nwhere the division is elementwise.</p>\n", "parameters": ["self", "speeds"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_cost", "modulename": "agd.Metrics.base", "qualname": "Base.with_cost", "type": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "parameters": ["self", "cost"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_speed", "modulename": "agd.Metrics.base", "qualname": "Base.with_speed", "type": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(x/speed)$.</p>\n", "parameters": ["self", "speed"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.flatten", "modulename": "agd.Metrics.base", "qualname": "Base.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.expand", "modulename": "agd.Metrics.base", "qualname": "Base.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.to_HFM", "modulename": "agd.Metrics.base", "qualname": "Base.to_HFM", "type": "function", "doc": "<p>Formats a metric for the HFM library. \nThis may include flattening some symmetric matrices, \nconcatenating with vector fields, and moving the first axis last.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.model_HFM", "modulename": "agd.Metrics.base", "qualname": "Base.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.from_HFM", "modulename": "agd.Metrics.base", "qualname": "Base.from_HFM", "type": "function", "doc": "<p>Inverse of the to_HFM member function.\nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.from_generator", "modulename": "agd.Metrics.base", "qualname": "Base.from_generator", "type": "function", "doc": "<p>Produce a metric from a suitable generator expression.</p>\n", "parameters": ["cls", "gen"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.from_cast", "modulename": "agd.Metrics.base", "qualname": "Base.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.array_float_caster", "modulename": "agd.Metrics.base", "qualname": "Base.array_float_caster", "type": "variable", "doc": "<p>Returns a caster function, which can be used to turn lists, etc, into\narrays with the suitable floating point type, from the suitable library \n(numpy or cupy), depending on the member fields.</p>\n"}, {"fullname": "agd.Metrics.base.Base.norm2", "modulename": "agd.Metrics.base", "qualname": "Base.norm2", "type": "function", "doc": "<p>Half square of the <code>norm</code>, defined by $F(v) := \\frac 1 2 N(v)^2$.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.gradient2", "modulename": "agd.Metrics.base", "qualname": "Base.gradient2", "type": "function", "doc": "<p>Gradient of <code>norm2</code>the half squared norm.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.set_interpolation", "modulename": "agd.Metrics.base", "qualname": "Base.set_interpolation", "type": "function", "doc": "<p>Sets interpolation_data, required to specialize the norm \nat a given position.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>grid (optional). Coordinate system (required on first call). </li>\n<li>kwargs. Passed to UniformGridInterpolation (includes order)</li>\n</ul>\n", "parameters": ["self", "grid", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.at", "modulename": "agd.Metrics.base", "qualname": "Base.at", "type": "function", "doc": "<p>Interpolates the metric to a given position, on a grid given beforehand.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>x. Place where interpolation is needed.</li>\n</ul>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal", "modulename": "agd.Metrics.diagonal", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal", "type": "class", "doc": "<p>A Diagonal norm takes the form \n$$\nF(x) = \\sqrt{\\sum_{0\\leq i &lt; d} c_i x_i^2 },\n$$\nwhere $(c_i)_{0\\leq i &lt; d}$, are given positive scalars</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>costs : the array of $(c_i)_{0\\leq i &lt; d}$ positive numbers. Required shape : $(d,n_1,..,n_k)$ where $d=$<code>vdim</code> is the ambient space dimension.</li>\n</ul>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal.__init__", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "costs"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.from_speed", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.from_speed", "type": "function", "doc": "<p>Produces a metric whose costs equal 1/speeds</p>\n", "parameters": ["cls", "speeds"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.dual", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.dual", "type": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.with_costs", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.with_costs", "type": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "parameters": ["self", "costs"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.norm", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.is_definite", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.is_definite", "type": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.anisotropy", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.anisotropy", "type": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.cost_bound", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.cost_bound", "type": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.vdim", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal.shape", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal.flatten", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.expand", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.model_HFM", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.from_cast", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic", "modulename": "agd.Metrics.isotropic", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic", "type": "class", "doc": "<p>An Isotropic norm takes the form \n$$\nF(x) = cost * \\sqrt{&lt; x,x>},\n$$\nwhere cost is a given positive scalar.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>cost : an array of arbirary shape (n1,..,nk).</li>\n<li>vdim (optional) : the ambient space dimension</li>\n</ul>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic.__init__", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "cost", "vdim"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.from_speed", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.from_speed", "type": "function", "doc": "<p>Produces a metric whose cost equals 1/speed.</p>\n", "parameters": ["cls", "speed", "vdim"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.dual", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.dual", "type": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.norm", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.is_definite", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.is_definite", "type": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.anisotropy", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.anisotropy", "type": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.cost_bound", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.cost_bound", "type": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.vdim", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic.shape", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic.rotate", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.rotate", "type": "function", "doc": "<p>Rotation of the norm, by a given rotation matrix.\nThe new unit ball is the direct image of the previous one.</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.with_cost", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.with_cost", "type": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "parameters": ["self", "cost"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.flatten", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.expand", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.to_HFM", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.to_HFM", "type": "function", "doc": "<p>Formats a metric for the HFM library. \nThis may include flattening some symmetric matrices, \nconcatenating with vector fields, and moving the first axis last.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.from_HFM", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.from_HFM", "type": "function", "doc": "<p>Inverse of the to_HFM member function.\nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.model_HFM", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.from_cast", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.misc", "modulename": "agd.Metrics.misc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.misc.flatten_symmetric_matrix", "modulename": "agd.Metrics.misc", "qualname": "flatten_symmetric_matrix", "type": "function", "doc": "<p>Input : a square (symmetric) matrix.\nOutput : a vector containing the lower triangular entries</p>\n", "parameters": ["m"], "funcdef": "def"}, {"fullname": "agd.Metrics.misc.expand_symmetric_matrix", "modulename": "agd.Metrics.misc", "qualname": "expand_symmetric_matrix", "type": "function", "doc": "<p></p>\n", "parameters": ["arr", "d", "extra_length"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander", "modulename": "agd.Metrics.rander", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.rander.Rander", "modulename": "agd.Metrics.rander", "qualname": "Rander", "type": "class", "doc": "<p>A Rander norm takes the form \n$$\nF(x) = \\sqrt{&lt; x,m.x>} + &lt; w,x>,\n$$\nwhere m is a given symmetric positive definite tensor, \nand w is a given vector subject to the consition $&lt; w,m^{-1} w> &lt; 1$.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape (vdim,vdim,n1,..,nk) where vdim is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all $0\\leq i&lt; j&lt; vdim$.</li>\n<li>w : an array of shape (vdim,n1,...,nk)</li>\n</ul>\n"}, {"fullname": "agd.Metrics.rander.Rander.__init__", "modulename": "agd.Metrics.rander", "qualname": "Rander.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "m", "w"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.norm", "modulename": "agd.Metrics.rander", "qualname": "Rander.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.dual", "modulename": "agd.Metrics.rander", "qualname": "Rander.dual", "type": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.vdim", "modulename": "agd.Metrics.rander", "qualname": "Rander.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.rander.Rander.shape", "modulename": "agd.Metrics.rander", "qualname": "Rander.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.rander.Rander.is_definite", "modulename": "agd.Metrics.rander", "qualname": "Rander.is_definite", "type": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.anisotropy_bound", "modulename": "agd.Metrics.rander", "qualname": "Rander.anisotropy_bound", "type": "function", "doc": "<p>An upper bound on the <code>anisotropy</code> of the norm.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.cost_bound", "modulename": "agd.Metrics.rander", "qualname": "Rander.cost_bound", "type": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.inv_transform", "modulename": "agd.Metrics.rander", "qualname": "Rander.inv_transform", "type": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.with_costs", "modulename": "agd.Metrics.rander", "qualname": "Rander.with_costs", "type": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "parameters": ["self", "costs"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.flatten", "modulename": "agd.Metrics.rander", "qualname": "Rander.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self", "inverse_m"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.expand", "modulename": "agd.Metrics.rander", "qualname": "Rander.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.model_HFM", "modulename": "agd.Metrics.rander", "qualname": "Rander.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.from_cast", "modulename": "agd.Metrics.rander", "qualname": "Rander.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.from_Zermelo", "modulename": "agd.Metrics.rander", "qualname": "Rander.from_Zermelo", "type": "function", "doc": "<p>Zermelo's navigation problem consists in computing a minimal path for \nwhose velocity is unit w.r.t. a Riemannian metric, and which is subject \nto a drift. The accessible velocities take the form \n        $x+drift$ where $&lt; x,m.x> \\leq 1$\nThis function reformulates it as a shortest path problem \nin a Rander manifold.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>metric : Symmetric positive definite matrix (Riemannian metric)</li>\n<li>drift : Vector field, obeying $&lt; drift,metric.drift> &lt; 1$ (Drift)</li>\n</ul>\n\n<p>Outputs : </p>\n\n<ul>\n<li>the Rander metric.</li>\n</ul>\n", "parameters": ["cls", "metric", "drift"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.to_Zermelo", "modulename": "agd.Metrics.rander", "qualname": "Rander.to_Zermelo", "type": "function", "doc": "<p>Input : Parameters of a Rander metric.</p>\n\n<p>Output : Parameters of the corresponding Zermelo problem, of motion on a \nRiemannian manifold with a drift.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.to_Varadhan", "modulename": "agd.Metrics.rander", "qualname": "Rander.to_Varadhan", "type": "function", "doc": "<p>The Rander eikonal equation can be reformulated in an (approximate)\nlinear form, using a logarithmic transformation\n        $u + 2 eps &lt; omega,grad u> - eps**2 Tr(D hess u)$.\nThen -eps log(u) solves the Rander eikonal equation, \nup to a small additional diffusive term.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>m and w, parameters of the Rander metric</li>\n<li>eps (optionnal), relaxation parameter</li>\n</ul>\n\n<p>Outputs : </p>\n\n<ul>\n<li>$D$ and $2 * omega$, parameters of the linear PDE. \n($D * eps^2$ and $2 * omega * eps$ if eps is specified)</li>\n</ul>\n", "parameters": ["eps"], "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.Varadhan_from_Zermelo", "modulename": "agd.Metrics.rander", "qualname": "Rander.Varadhan_from_Zermelo", "type": "function", "doc": "<p>Zermelo's navigation problem can be turned into a Rander shortest path problem,\nwhich itself can be (approximately) expressed in linear form using the logarithmic\ntransformation. This function composes the above two steps.</p>\n", "parameters": ["metric", "drift", "eps"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann", "modulename": "agd.Metrics.riemann", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.riemann.Riemann", "modulename": "agd.Metrics.riemann", "qualname": "Riemann", "type": "class", "doc": "<p>A Riemann norm takes the form \n$$\nF(x) = \\sqrt{&lt; x,m x>}, \n$$\nwhere m is a given symmetric positive definite tensor.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape $(d,d,n_1,..,n_k)$ where d=<code>vdim</code> is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all $0\\leq i &lt; j &lt; d$.</li>\n</ul>\n"}, {"fullname": "agd.Metrics.riemann.Riemann.__init__", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "m"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.norm", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.norm", "type": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.dual", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.dual", "type": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.vdim", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.vdim", "type": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.riemann.Riemann.shape", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.shape", "type": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.riemann.Riemann.eigvals", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.eigvals", "type": "function", "doc": "<p>Eigenvalues of self.m</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.is_definite", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.is_definite", "type": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.anisotropy", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.anisotropy", "type": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.cost_bound", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.cost_bound", "type": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.inv_transform", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.inv_transform", "type": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "parameters": ["self", "a"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.with_costs", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.with_costs", "type": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "parameters": ["self", "costs"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.flatten", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.flatten", "type": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.expand", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.expand", "type": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "parameters": ["cls", "arr"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.model_HFM", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.model_HFM", "type": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.needle", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.needle", "type": "function", "doc": "<p>Defines a Riemannian metric, with </p>\n\n<ul>\n<li>eigenvector u</li>\n<li>eigenvalue cost_parallel**2 in the eigenspace spanned by u</li>\n<li>eigenvalue cost_orthogonal**2 in the eigenspace orthogonal with u</li>\n</ul>\n\n<p>The metric is </p>\n\n<ul>\n<li>needle-like if cost_parallel &lt; cost_orthogonal</li>\n<li>plate-like otherwise</li>\n</ul>\n\n<p>Optional argument:</p>\n\n<ul>\n<li>ret_u : wether to return the (normalized) vector u</li>\n</ul>\n", "parameters": ["cls", "u", "cost_parallel", "cost_orthogonal", "ret_u"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.from_diagonal", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.from_diagonal", "type": "function", "doc": "<p>Produces a Riemann norm whose tensors have the given diagonal.</p>\n", "parameters": ["cls", "diag"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.from_cast", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.from_cast", "type": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "parameters": ["cls", "metric"], "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.from_mapped_eigenvalues", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.from_mapped_eigenvalues", "type": "function", "doc": "<p>Defines a Riemannian metric which has the same eigenvectors as the provided \nmatrix, but (possibly) distinct eigenvalues obtained by the provided mapping.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>matrix: a symmetric matrix, with shape (dim,dim,...)</li>\n<li>mapping: a function, taking as input an array of shape (dim,...),\n    and returning a similarly shaped array. \n    Called with the eigenvalues of matrix, sorted from smallest to largest.</li>\n</ul>\n", "parameters": ["cls", "matrix", "mapping"], "funcdef": "def"}, {"fullname": "agd.ODE", "modulename": "agd.ODE", "qualname": "", "type": "module", "doc": "<p>The ODE package provides basic functionality for generating ODEs, and solving them.</p>\n\n<p>Main submodules:</p>\n\n<ul>\n<li>hamiltonian : defines classes of hamiltonians with various mathematical structures,\n(separable, quadratic, associated with a metric, ...)</li>\n<li>hamiltonian_base : contains the base class for the hamiltonians, and some symplectic \nODE solvers.</li>\n<li>backtrack : tools intended for path backtracking in time dependent optimal control</li>\n</ul>\n"}, {"fullname": "agd.ODE.backtrack", "modulename": "agd.ODE.backtrack", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.backtrack.odeint_array", "modulename": "agd.ODE.backtrack", "qualname": "odeint_array", "type": "function", "doc": "<p>Solve an ODE where the vector field is interpolated from an array.\nThe vector field is linearly interpolated, and the Euler midpoint scheme is used.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>f : generator of the vector fields to be interpolated, len(next(f))=vdim</li>\n<li>y : initial value of the solution, len(y) = vdim </li>\n<li>t : time steps</li>\n<li>grid : interpolation grid for the vector field f</li>\n<li>t_delay : number of time steps to drop initially </li>\n<li>t_substeps : number of substeps</li>\n<li>order : passed to odeint_array</li>\n<li>**kwargs : passed to UniformGridInterpolation</li>\n</ul>\n", "parameters": ["f", "y", "t", "grid", "t_delay", "t_substeps", "order", "kwargs"], "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind", "type": "class", "doc": "<p>This class is designed to iterate a function, and then roll back the iterations, \nwith a limited memory usage. For that purpose appropriate keypoints are stored,\n in a multilevel manner.\n__init__ args: </p>\n\n<ul>\n<li>next : method to compute the next step.</li>\n<li>initial : initial value</li>\n<li>params : passed to next, in addition to current value</li>\n<li>base : base $b$ used to internally represent the iteration counter, which balances \na tradeoff between memory usage and computational cost. Iterating $O(b^n)$ times\nand then rewinding these iterations, has a storage cost of $O(n*b)$ and a \ncomputational cost of $O(n * b^n)$ function evaluations.</li>\n</ul>\n\n<p>members:</p>\n\n<ul>\n<li>reversed : wether __next__ should advance or rewind the iterations</li>\n</ul>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.__init__", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "next", "initial", "params", "base"], "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.advance", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.advance", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.rewind", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.rewind", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.index", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.index", "type": "variable", "doc": "<p>The index of the current iteration</p>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.value", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.value", "type": "function", "doc": "<p>The value of the current iteration</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.base", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.base", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.MetricHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "MetricHamiltonian", "type": "class", "doc": "<p>Hamiltonian defined by an interpolated metric, which is dualized and interpolated.\n$$\nH(q,p) = \\frac 1 2 F^*_q(p)^2\n$$\n__init__ arguments :</p>\n\n<ul>\n<li>metric : dual defines the hamiltonian</li>\n<li>inv_inner : passed to HamiltonianBase</li>\n<li>**kwargs : passed to metric.dual().set_interpolation</li>\n</ul>\n"}, {"fullname": "agd.ODE.hamiltonian.MetricHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "MetricHamiltonian.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "metric", "inv_inner", "kwargs"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian", "type": "class", "doc": "<p>Hamiltonian defined by a arbitrary function $f$ of two variables, \nthe position $q$ and impulsion $p$.\n$$\nH(q,p) = f(q,p)\n$$</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>func : the function $f$ defining the hamiltonian, must take two arguments.</li>\n<li>disassociate_ad (optional) : hide AD information when calling $f$. (Use to avoid \nconflicts if the definition of $f$ itself involves automatic differentiation.)</li>\n<li>shape_free (optional) : shape of position and momentum variables</li>\n<li>**kwargs : passed to HamiltonianBase</li>\n</ul>\n"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "func", "disassociate_ad", "kwargs"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian", "type": "class", "doc": "<p>Separable Hamiltonian defined by a pair of functions.\n$$\n        H(q,p) = H_Q(q) + H_P(p).\n$$\n__init__ arguments : </p>\n\n<ul>\n<li>Hq,Hp : the two functions $H_Q,H_P$, of a single argument, defining the hamiltonian</li>\n<li>**kwargs : passed to HamiltonianBase</li>\n</ul>\n"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "Hq", "Hp", "kwargs"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian", "type": "class", "doc": "<p>Quadratic Hamiltonian, defined by a pair of linear operators.\n(Expected to be symmetric semi-definite.)\n$$\n        H(q,p) = \\frac 1 2 (&lt; q, M_Q q &gt; +&lt; p, M_P p &gt;).\n$$</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>Mq,Mp : positive semi-definite matrices $M_Q,M_P$, typically given in sparse form.\nAlternatively, define Mq,Mp as functions, and use the set_spmat\nto automatically generate the sparse matrices using automatic differentiation.</li>\n</ul>\n"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "Mq", "Mp", "kwargs"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.flat", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.flat", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.spmat", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.spmat", "type": "function", "doc": "<p>Returns the sparse matrix associated to the hessian of f at x,\ngenerated using automatic differentiation.\nOutput of f is summed, if non-scalar.</p>\n\n<ul>\n<li>simplify_ad (optional): wether to simplify the ad information \nbefore generating the sparse matrix</li>\n<li>inv_inner : inverse inner product, for gradient normalization</li>\n</ul>\n", "parameters": ["cls", "f", "x", "simplify_ad"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.set_spmat", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.set_spmat", "type": "function", "doc": "<p>Replaces Mq,Mp and inv_inner with suitable sparse matrices, generated by spmat,\nif they are callables.</p>\n", "parameters": ["self", "x", "kwargs"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base", "modulename": "agd.ODE.hamiltonian_base", "qualname": "", "type": "module", "doc": "<p>This module implements some basic functionality for solving ODEs derived from a \nHamiltonian in a manner compatible with automatic differentiation.\n(Flow computation, symplectic schemes, etc)</p>\n\n<p>Recall that Hamilton's equations read \n$$\n\\frac {dq}{dt} = \\frac {\\partial H}{\\partial p},\n\\quad\n\\frac {dp}{dt} = - \\frac {\\partial H}{\\partial q}.\n$$</p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.fixedpoint", "modulename": "agd.ODE.hamiltonian_base", "qualname": "fixedpoint", "type": "function", "doc": "<p>Iterates the function f on the data x until a fixed point is found, \nup to prescribed tolerance, or the maximum number of iterations is reached.</p>\n", "parameters": ["f", "x", "tol", "nitermax"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase", "type": "class", "doc": "<p>Base class for Hamiltonians.</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>shape_free (optional) : shape of the position and momentum variables</li>\n<li>inv_inner (optional): inverse inner product, used for gradient normalization</li>\n</ul>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.__init__", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "is_separable", "inv_inner", "shape_free", "vdim"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.vdim", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.vdim", "type": "variable", "doc": "<p>Dimension of space of positions. \n(Also equals the dimension of the space of impulsions)\nSet to None for a Hamiltonian acting on scalars.</p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.size_free", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.size_free", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.ndim_free", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.ndim_free", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.H", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.H", "type": "function", "doc": "<p>Evaluates the Hamiltonian, at a given position and impulsion.</p>\n", "parameters": ["self", "q", "p"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.DqH", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.DqH", "type": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. position.</p>\n", "parameters": ["self", "q", "p"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.DpH", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.DpH", "type": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. impulsion.</p>\n", "parameters": ["self", "q", "p"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.flow", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.flow", "type": "function", "doc": "<p>Symplectic gradient of the Hamiltonian.</p>\n", "parameters": ["self", "q", "p"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.flow_cat", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.flow_cat", "type": "function", "doc": "<p>Symplectic gradient of the hamiltonian, intended for odeint. </p>\n\n<p>Input : </p>\n\n<ul>\n<li>qp : position q, impulsion p, concatenated and flattened.</li>\n<li>t : ignored parameter (compatibility with scipy.integrate.odeint)</li>\n</ul>\n\n<p>Output :</p>\n\n<ul>\n<li>symplectic gradient, concatenated and flattened.</li>\n</ul>\n", "parameters": ["self", "qp", "t"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.integrate", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.integrate", "type": "function", "doc": "<p>Solves Hamilton's equations by running the scheme niter times.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>q,p : Initial position and impulsion.</li>\n<li>scheme : ODE integration scheme. (string or callable)</li>\n<li>niter,dt,T : number of steps, time step, and total time\n      (exactly two among the three must be specified)</li>\n<li>path : wether to return the intermediate steps. \n       (If a positive number, period of intermediate steps to return)</li>\n</ul>\n\n<p>Output : </p>\n\n<ul>\n<li>q,p if path is False. \nOtherwise [q0,...,qn],[p0,...,pn],[t0,..tn], with n=niter, tn=T.</li>\n</ul>\n", "parameters": ["self", "q", "p", "scheme", "niter", "dt", "T", "path"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.nonsymplectic_schemes", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.nonsymplectic_schemes", "type": "function", "doc": "<p>Standard ODE integration schemes</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.incomplete_schemes", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.incomplete_schemes", "type": "function", "doc": "<p>Incomplete schemes, updating only position or impulsion. \nInputs : \n        - solver (optional). Numerical solver used for the implicit steps.\n        Defaults to a basic fixed point solver: \"fixedpoint\" in the same package.</p>\n", "parameters": ["self", "solver"], "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.symplectic_schemes", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.symplectic_schemes", "type": "function", "doc": "<p>Symplectic schemes, alternating updates of position and impulsion.\nThe first updated variable is indicated with a suffix.</p>\n\n<p>In the non-separable cases, some of the updates are implicit, otherwise\nthey are explicit.\nInputs : \n        - kwargs. Passed to self.incomplete_schemes</p>\n", "parameters": ["self", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Plotting", "modulename": "agd.Plotting", "qualname": "", "type": "module", "doc": "<p>This module gathers a few helper functions for plotting data, that are used throughout the \nillustrative notebooks.</p>\n"}, {"fullname": "agd.Plotting.SetTitle3D", "modulename": "agd.Plotting", "qualname": "SetTitle3D", "type": "function", "doc": "<p></p>\n", "parameters": ["ax", "title"], "funcdef": "def"}, {"fullname": "agd.Plotting.savefig", "modulename": "agd.Plotting", "qualname": "savefig", "type": "function", "doc": "<p>Save a figure:</p>\n\n<ul>\n<li>in a given directory, possibly set in the properties of the function. \nSilently fails if dirName is None</li>\n<li>with defaulted arguments, possibly set in the properties of the function</li>\n</ul>\n", "parameters": ["fig", "fileName", "dirName", "ax", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Plotting.animation_curve", "modulename": "agd.Plotting", "qualname": "animation_curve", "type": "function", "doc": "<p>Animates a sequence of curves Y[0],Y[1],... with X as horizontal axis</p>\n", "parameters": ["X", "Y", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Plotting.quiver", "modulename": "agd.Plotting", "qualname": "quiver", "type": "function", "doc": "<p>Pyplot quiver with additional arg:</p>\n\n<ul>\n<li>subsampling (tuple). Subsample X,Y,U,V</li>\n</ul>\n", "parameters": ["X", "Y", "U", "V", "subsampling", "kwargs"], "funcdef": "def"}, {"fullname": "agd.Selling", "modulename": "agd.Selling", "qualname": "", "type": "module", "doc": "<p>This file implements Selling's algorithm in dimension $d \\in \\{2,3\\}$, which decomposes a \nsymmetric positive definite matrix $D$, of dimension $d\\leq 3$, in the form \n$$\n        D = \\sum_{0\\leq i &lt; I} a_i e_i e_i^\\top,\n$$\nwhere $a_i \\geq 0$ and $e_i\\in Z^d$ is a vector with integer coordinates, \nand where $I = d(d+2)/2$.</p>\n\n<p>Selling's decomposition is a central tool in the design of adaptive discretization schemes\nfor anisotropic partial differential equations, on Cartesian grids.</p>\n"}, {"fullname": "agd.Selling.ObtuseSuperbase", "modulename": "agd.Selling", "qualname": "ObtuseSuperbase", "type": "function", "doc": "<p>Input : </p>\n\n<ul>\n<li>m : symmetric positive definite matrix, defined as an\narray of shape $(d,d, n_1,...,n_k)$.</li>\n<li>sb (optional) : initial guess for the obtuse superbase.</li>\n</ul>\n\n<p>Ouput : an m-obtuse superbase</p>\n", "parameters": ["m", "sb"], "funcdef": "def"}, {"fullname": "agd.Selling.Decomposition", "modulename": "agd.Selling", "qualname": "Decomposition", "type": "function", "doc": "<p>Use Selling's algorithm to decompose a tensor</p>\n\n<p>Input : </p>\n\n<ul>\n<li>m : symmetric positive definite matrix, defined as an\narray of shape $(d,d, n_1,...,n_k)$ where $d\\leq 3$.</li>\n<li>sb (optional) : superbase to use for the decomposition,\narray of shape $(d,d+1, n_1,...,n_k)$.\nOutput : the coefficients and offsets of the decomposition.</li>\n</ul>\n", "parameters": ["m", "sb"], "funcdef": "def"}, {"fullname": "agd.Selling.GatherByOffset", "modulename": "agd.Selling", "qualname": "GatherByOffset", "type": "function", "doc": "<p>Get the coefficient of each offset.\nThis function is essentially used to make nice plots of how the superbase coefficients\nand offsets vary as the decomposed tensor varies.</p>\n", "parameters": ["T", "Coefs", "Offsets"], "funcdef": "def"}, {"fullname": "agd.Selling.CanonicalSuperbase", "modulename": "agd.Selling", "qualname": "CanonicalSuperbase", "type": "function", "doc": "<p>Returns a superbase with the same dimensions and array type as m.</p>\n\n<p>Output : </p>\n\n<ul>\n<li>m : array of shape $(d,d, n_1,...,n_k)$</li>\n</ul>\n", "parameters": ["m"], "funcdef": "def"}, {"fullname": "agd.Selling.SuperbasesForConditioning", "modulename": "agd.Selling", "qualname": "SuperbasesForConditioning", "type": "function", "doc": "<p>Returns a family of superbases. \nFor any positive definite matrix $M$ with condition number below the given bound,\none of these superbases will be $M$-obtuse.\n(Condition number is the ratio of the largest to the smallest eigenvalue.)</p>\n\n<p>Input : </p>\n\n<ul>\n<li>cond (scalar) : the bound on the condition number.</li>\n</ul>\n", "parameters": ["cond", "dim"], "funcdef": "def"}, {"fullname": "agd.Sphere", "modulename": "agd.Sphere", "qualname": "", "type": "module", "doc": "<p>This module provides basic conversion utilities to manipulate low-dimensional spheres, \nand related objects : rotations, quaternions, Pauli matrices, etc</p>\n"}, {"fullname": "agd.Sphere.sphere_from_plane", "modulename": "agd.Sphere", "qualname": "sphere_from_plane", "type": "function", "doc": "<p>Produces a point in the unit sphere by projecting a point in the equator plane.</p>\n", "parameters": ["e"], "funcdef": "def"}, {"fullname": "agd.Sphere.plane_from_sphere", "modulename": "agd.Sphere", "qualname": "plane_from_sphere", "type": "function", "doc": "<p>Produces a point in the equator plane from a point in the unit sphere.</p>\n", "parameters": ["q"], "funcdef": "def"}, {"fullname": "agd.Sphere.rotation3_from_sphere3", "modulename": "agd.Sphere", "qualname": "rotation3_from_sphere3", "type": "function", "doc": "<p>Produces the rotation associated with a unit quaternion.</p>\n", "parameters": ["q"], "funcdef": "def"}, {"fullname": "agd.Sphere.sphere3_from_rotation3", "modulename": "agd.Sphere", "qualname": "sphere3_from_rotation3", "type": "function", "doc": "<p>Produces the unit quaternion, with positive real part, associated with a rotation.</p>\n", "parameters": ["r"], "funcdef": "def"}, {"fullname": "agd.Sphere.ball3_from_rotation3", "modulename": "agd.Sphere", "qualname": "ball3_from_rotation3", "type": "function", "doc": "<p>Produces an euclidean point from a rotation, \nselecting in the intermediate step the quaternion \nin the same hemisphere as qRef. (Defaults to southern.)</p>\n", "parameters": ["r", "qRef"], "funcdef": "def"}, {"fullname": "agd.Sphere.rotation3_from_ball3", "modulename": "agd.Sphere", "qualname": "rotation3_from_ball3", "type": "function", "doc": "<p>Produces a rotation from an euclidean point. \nAlso returns the intermediate quaternion.</p>\n", "parameters": ["e"], "funcdef": "def"}, {"fullname": "agd.Sphere.pauli", "modulename": "agd.Sphere", "qualname": "pauli", "type": "function", "doc": "<p>Pauli matrix. Symmetric if d is None, Hermitian otherwise.\nDeterminant is $a^2-b^2-c^2-d^2$</p>\n", "parameters": ["a", "b", "c", "d"], "funcdef": "def"}]